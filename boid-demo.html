<!DOCTYPE html>
<html lang="fi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Secret Life of Boids - Otto Juote Edition</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'IBM Plex Mono', monospace;
      background: #0f0f1a;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    h1 {
      color: #D4AF37;
      font-size: 24px;
      margin-bottom: 8px;
      text-align: center;
    }

    .subtitle {
      color: rgba(255, 255, 255, 0.4);
      font-size: 12px;
      margin-bottom: 24px;
      text-align: center;
    }

    .container {
      width: 100%;
      max-width: 900px;
      background: #1a1a2e;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    canvas {
      display: block;
      width: 100%;
      height: 500px;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 16px 20px;
      background: rgba(0, 0, 0, 0.3);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      flex-wrap: wrap;
    }

    button {
      padding: 10px 20px;
      border: 1px solid rgba(212, 175, 55, 0.3);
      background: rgba(212, 175, 55, 0.1);
      color: #D4AF37;
      border-radius: 8px;
      cursor: pointer;
      font-family: inherit;
      font-size: 13px;
      transition: all 0.2s ease;
    }

    button:hover {
      background: rgba(212, 175, 55, 0.2);
      border-color: rgba(212, 175, 55, 0.5);
    }

    button.active {
      background: rgba(212, 175, 55, 0.3);
      border-color: #D4AF37;
    }

    .toggles {
      display: flex;
      gap: 20px;
      margin-left: auto;
    }

    label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      color: rgba(255, 255, 255, 0.6);
      font-size: 12px;
    }

    label:hover {
      color: rgba(255, 255, 255, 0.8);
    }

    input[type="checkbox"] {
      appearance: none;
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      background: transparent;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    input[type="checkbox"]:checked {
      background: #D4AF37;
      border-color: #D4AF37;
    }

    .rules {
      display: flex;
      justify-content: center;
      gap: 30px;
      padding: 14px 20px;
      background: rgba(0, 0, 0, 0.4);
      border-top: 1px solid rgba(255, 255, 255, 0.05);
    }

    .rule {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 11px;
    }

    .rule-icon {
      font-weight: bold;
      padding: 4px 8px;
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.1);
    }

    .rule-icon.sep { color: #ff6b6b; }
    .rule-icon.align { color: #4ecdc4; }
    .rule-icon.coh { color: #45b7d1; }

    .rule-text {
      color: rgba(255, 255, 255, 0.5);
    }

    .credits {
      margin-top: 24px;
      color: rgba(255, 255, 255, 0.3);
      font-size: 10px;
      text-align: center;
    }

    @media (max-width: 600px) {
      .rules {
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }
      .toggles {
        width: 100%;
        justify-content: center;
        margin-left: 0;
        margin-top: 10px;
      }
    }
  </style>
</head>
<body>
  <h1>The Secret Life of Boids</h1>
  <p class="subtitle">Otto Juote Edition — Emergent Behavior from Simple Rules</p>

  <div class="container">
    <canvas id="boidCanvas"></canvas>

    <div class="controls">
      <button id="playPauseBtn" class="active">⏸ Pause</button>
      <button id="resetBtn">↺ Reset</button>

      <div class="toggles">
        <label>
          <input type="checkbox" id="trailsToggle" checked>
          Trails
        </label>
        <label>
          <input type="checkbox" id="connectionsToggle" checked>
          Connections
        </label>
        <label>
          <input type="checkbox" id="zonesToggle">
          Force Zones
        </label>
      </div>
    </div>

    <div class="rules">
      <div class="rule">
        <span class="rule-icon sep">←→</span>
        <span class="rule-text">Separation (Repulsion)</span>
      </div>
      <div class="rule">
        <span class="rule-icon align">→→</span>
        <span class="rule-text">Alignment</span>
      </div>
      <div class="rule">
        <span class="rule-icon coh">•→•</span>
        <span class="rule-text">Cohesion (Attraction)</span>
      </div>
    </div>
  </div>

  <p class="credits">
    Based on Craig Reynolds' Boids algorithm (1986)<br>
    Three simple rules create emergent flocking behavior
  </p>

  <script>
    // ===========================================
    // Vector2D Class
    // ===========================================
    class Vector2D {
      constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
      }

      add(v) { return new Vector2D(this.x + v.x, this.y + v.y); }
      subtract(v) { return new Vector2D(this.x - v.x, this.y - v.y); }
      multiply(s) { return new Vector2D(this.x * s, this.y * s); }
      divide(s) { return s === 0 ? new Vector2D(0, 0) : new Vector2D(this.x / s, this.y / s); }
      magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y); }
      normalize() { const m = this.magnitude(); return m === 0 ? new Vector2D(0, 0) : this.divide(m); }
      limit(max) { return this.magnitude() > max ? this.normalize().multiply(max) : new Vector2D(this.x, this.y); }
      distance(v) { return this.subtract(v).magnitude(); }
      angle() { return Math.atan2(this.y, this.x); }
      static random(min = -1, max = 1) {
        return new Vector2D(min + Math.random() * (max - min), min + Math.random() * (max - min));
      }
    }

    // ===========================================
    // Boid Class
    // ===========================================
    class Boid {
      constructor(name, x, y, color, personality = {}) {
        this.name = name;
        this.position = new Vector2D(x, y);
        this.velocity = Vector2D.random(-2, 2);
        this.acceleration = new Vector2D(0, 0);
        this.color = color;

        this.personality = {
          separationWeight: personality.separationWeight || 1.5,
          alignmentWeight: personality.alignmentWeight || 1.0,
          cohesionWeight: personality.cohesionWeight || 1.0,
          maxSpeed: personality.maxSpeed || 4,
          maxForce: personality.maxForce || 0.1,
          perceptionRadius: personality.perceptionRadius || 100,
          separationRadius: personality.separationRadius || 50
        };

        this.trail = [];
        this.maxTrailLength = 20;
      }

      // Rule 1: SEPARATION
      separate(boids) {
        let steering = new Vector2D(0, 0);
        let count = 0;

        for (const other of boids) {
          if (other === this) continue;
          const distance = this.position.distance(other.position);
          if (distance > 0 && distance < this.personality.separationRadius) {
            let diff = this.position.subtract(other.position).normalize().divide(distance);
            steering = steering.add(diff);
            count++;
          }
        }

        if (count > 0) {
          steering = steering.divide(count).normalize().multiply(this.personality.maxSpeed);
          steering = steering.subtract(this.velocity).limit(this.personality.maxForce);
        }
        return steering.multiply(this.personality.separationWeight);
      }

      // Rule 2: ALIGNMENT
      align(boids) {
        let steering = new Vector2D(0, 0);
        let count = 0;

        for (const other of boids) {
          if (other === this) continue;
          const distance = this.position.distance(other.position);
          if (distance > 0 && distance < this.personality.perceptionRadius) {
            steering = steering.add(other.velocity);
            count++;
          }
        }

        if (count > 0) {
          steering = steering.divide(count).normalize().multiply(this.personality.maxSpeed);
          steering = steering.subtract(this.velocity).limit(this.personality.maxForce);
        }
        return steering.multiply(this.personality.alignmentWeight);
      }

      // Rule 3: COHESION
      cohere(boids) {
        let steering = new Vector2D(0, 0);
        let count = 0;

        for (const other of boids) {
          if (other === this) continue;
          const distance = this.position.distance(other.position);
          if (distance > 0 && distance < this.personality.perceptionRadius) {
            steering = steering.add(other.position);
            count++;
          }
        }

        if (count > 0) {
          steering = steering.divide(count).subtract(this.position).normalize();
          steering = steering.multiply(this.personality.maxSpeed).subtract(this.velocity);
          steering = steering.limit(this.personality.maxForce);
        }
        return steering.multiply(this.personality.cohesionWeight);
      }

      flock(boids) {
        this.acceleration = this.acceleration.add(this.separate(boids));
        this.acceleration = this.acceleration.add(this.align(boids));
        this.acceleration = this.acceleration.add(this.cohere(boids));
      }

      edges(width, height) {
        if (this.position.x > width) this.position.x = 0;
        if (this.position.x < 0) this.position.x = width;
        if (this.position.y > height) this.position.y = 0;
        if (this.position.y < 0) this.position.y = height;
      }

      update() {
        this.trail.push(new Vector2D(this.position.x, this.position.y));
        if (this.trail.length > this.maxTrailLength) this.trail.shift();

        this.velocity = this.velocity.add(this.acceleration).limit(this.personality.maxSpeed);
        this.position = this.position.add(this.velocity);
        this.acceleration = new Vector2D(0, 0);
      }
    }

    // ===========================================
    // Simulation & Rendering
    // ===========================================
    const canvas = document.getElementById('boidCanvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    let boids = [];
    let isRunning = true;
    let showTrails = true;
    let showConnections = true;
    let showForceZones = false;

    function resize() {
      const rect = canvas.parentElement.getBoundingClientRect();
      width = rect.width;
      height = 500;
      canvas.width = width;
      canvas.height = height;
    }

    function initBoids() {
      boids = [
        new Boid('Otto', width * 0.3, height * 0.5, '#D4AF37', {
          separationWeight: 1.2, alignmentWeight: 1.0, cohesionWeight: 1.5,
          maxSpeed: 3.5, maxForce: 0.12, perceptionRadius: 120, separationRadius: 40
        }),
        new Boid('Juote', width * 0.5, height * 0.3, '#8B4513', {
          separationWeight: 2.0, alignmentWeight: 0.8, cohesionWeight: 1.0,
          maxSpeed: 4.5, maxForce: 0.15, perceptionRadius: 80, separationRadius: 60
        }),
        new Boid('Taika', width * 0.7, height * 0.6, '#4A0E4E', {
          separationWeight: 1.0, alignmentWeight: 1.5, cohesionWeight: 2.0,
          maxSpeed: 3.0, maxForce: 0.1, perceptionRadius: 150, separationRadius: 35
        })
      ];
    }

    function drawBoid(boid) {
      const pos = boid.position;
      const angle = boid.velocity.angle();
      const size = 15;

      ctx.save();
      ctx.translate(pos.x, pos.y);
      ctx.rotate(angle);

      // Glow
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 2);
      gradient.addColorStop(0, boid.color + '40');
      gradient.addColorStop(1, 'transparent');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, size * 2, 0, Math.PI * 2);
      ctx.fill();

      // Body
      ctx.fillStyle = boid.color;
      ctx.strokeStyle = '#ffffff40';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(size, 0);
      ctx.lineTo(-size * 0.7, -size * 0.5);
      ctx.lineTo(-size * 0.4, 0);
      ctx.lineTo(-size * 0.7, size * 0.5);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      ctx.restore();

      // Name
      ctx.font = '11px "IBM Plex Mono", monospace';
      ctx.fillStyle = boid.color;
      ctx.textAlign = 'center';
      ctx.fillText(boid.name, pos.x, pos.y - 22);
    }

    function drawTrail(boid) {
      if (!showTrails || boid.trail.length < 2) return;
      ctx.beginPath();
      ctx.moveTo(boid.trail[0].x, boid.trail[0].y);
      for (let i = 1; i < boid.trail.length; i++) {
        ctx.lineTo(boid.trail[i].x, boid.trail[i].y);
      }
      const gradient = ctx.createLinearGradient(
        boid.trail[0].x, boid.trail[0].y,
        boid.trail[boid.trail.length - 1].x, boid.trail[boid.trail.length - 1].y
      );
      gradient.addColorStop(0, 'transparent');
      gradient.addColorStop(1, boid.color + '60');
      ctx.strokeStyle = gradient;
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';
      ctx.stroke();
    }

    function drawConnections() {
      if (!showConnections) return;
      for (let i = 0; i < boids.length; i++) {
        for (let j = i + 1; j < boids.length; j++) {
          const distance = boids[i].position.distance(boids[j].position);
          const maxDist = Math.max(boids[i].personality.perceptionRadius, boids[j].personality.perceptionRadius);
          if (distance < maxDist) {
            const opacity = Math.max(0, 1 - distance / maxDist) * 0.3;
            ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(boids[i].position.x, boids[i].position.y);
            ctx.lineTo(boids[j].position.x, boids[j].position.y);
            ctx.stroke();
          }
        }
      }
    }

    function drawForceZones(boid) {
      if (!showForceZones) return;
      ctx.strokeStyle = boid.color + '30';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.arc(boid.position.x, boid.position.y, boid.personality.perceptionRadius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.strokeStyle = '#ff000030';
      ctx.beginPath();
      ctx.arc(boid.position.x, boid.position.y, boid.personality.separationRadius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawLegend() {
      ctx.font = '14px "IBM Plex Mono", monospace';
      ctx.fillStyle = '#D4AF37';
      ctx.textAlign = 'left';
      ctx.fillText('The Secret Life of Boids', 20, 30);
      ctx.font = '10px "IBM Plex Mono", monospace';
      ctx.fillStyle = '#ffffff50';
      ctx.fillText('Otto Juote Edition', 20, 48);

      // Stats
      let avgDist = 0, count = 0;
      for (let i = 0; i < boids.length; i++) {
        for (let j = i + 1; j < boids.length; j++) {
          avgDist += boids[i].position.distance(boids[j].position);
          count++;
        }
      }
      avgDist = count > 0 ? (avgDist / count).toFixed(0) : 0;

      ctx.textAlign = 'right';
      ctx.fillStyle = '#ffffff40';
      ctx.fillText(`Avg Distance: ${avgDist}px`, width - 20, 30);
    }

    function render() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, width, height);

      drawConnections();
      for (const boid of boids) {
        drawForceZones(boid);
        drawTrail(boid);
        drawBoid(boid);
      }
      drawLegend();
    }

    function update() {
      if (isRunning) {
        for (const boid of boids) {
          boid.flock(boids);
          boid.update();
          boid.edges(width, height);
        }
      }
    }

    function animate() {
      update();
      render();
      requestAnimationFrame(animate);
    }

    // Controls
    document.getElementById('playPauseBtn').addEventListener('click', function() {
      isRunning = !isRunning;
      this.textContent = isRunning ? '⏸ Pause' : '▶ Play';
      this.classList.toggle('active', isRunning);
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      initBoids();
    });

    document.getElementById('trailsToggle').addEventListener('change', function() {
      showTrails = this.checked;
    });

    document.getElementById('connectionsToggle').addEventListener('change', function() {
      showConnections = this.checked;
    });

    document.getElementById('zonesToggle').addEventListener('change', function() {
      showForceZones = this.checked;
    });

    window.addEventListener('resize', () => {
      resize();
    });

    // Initialize
    resize();
    initBoids();
    animate();
  </script>
</body>
</html>
