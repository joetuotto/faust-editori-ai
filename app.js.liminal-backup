/**
 * FAUST - Simple Clean Implementation
 * Uses new faust-simple-layout.css
 * v2.0: Project structure for AI book generation
 */

const { createElement: e, useState, useEffect, useRef } = React;

// Create default project structure
const createDefaultProject = () => ({
  title: 'Nimet√∂n projekti',
  author: '',
  genre: 'fiction',
  language: 'fi',
  created: new Date().toISOString(),
  modified: new Date().toISOString(),
  version: '2.0',

  // Content structure (hierarchical)
  // Types: 'folder', 'chapter', 'scene'
  structure: [
    {
      id: 'chapter-1',
      type: 'chapter',
      title: 'Luku 1',
      order: 0,
      content: '',
      wordCount: 0,
      children: [],

      // AI-Enhanced Metadata
      synopsis: '',  // AI-generated or manual
      synopsisAI: '', // AI-generated version
      synopsisManual: '', // User override

      notes: '',     // Research notes, ideas
      notesAI: {
        characterMentions: [],  // AI-detected characters
        locations: [],          // AI-detected places
        timeframe: '',          // AI-detected time
        mood: '',               // AI-analyzed mood
        themes: [],             // AI-detected themes
        continuityIssues: []    // AI-found problems
      },

      // Status & Quality
      status: 'draft', // draft, revised, final
      aiQuality: {
        score: 0,              // 0-10 AI quality rating
        lastAnalyzed: null,
        issues: [],            // [{type, severity, msg}]
        strengths: [],         // What's good
        suggestions: [],       // How to improve
        readiness: 'draft'     // AI recommendation
      },

      // Structure hints
      structureHints: {
        shouldBeSplit: false,       // AI suggests splitting
        suggestedSceneBreaks: [],   // Positions for scene breaks
        relatedChapters: [],        // Similar content elsewhere
        missingTransition: false    // Needs better flow
      },

      // Pacing
      pacing: {
        speed: 'medium',      // slow, medium, fast (AI-analyzed)
        tension: 0,           // 0-10
        wordDensity: 0,       // words per concept
        dialogueRatio: 0      // % dialogue vs narrative
      },

      label: '',     // User-defined label/color
      color: '',     // For corkboard view

      created: new Date().toISOString(),
      modified: new Date().toISOString(),

      // Version history
      versions: []   // [{timestamp, content, aiDiff}]
    }
  ],

  // Outline for AI generation
  outline: [],

  // Knowledge base
  characters: [],
  locations: [],
  timeline: [],

  // Cast planning (Phase 1 of Character Archetype Builder)
  castPlan: {
    defined: false,
    characterTypes: [],  // User-defined types like "stoic elder", "young idealist"
    totalCharacters: 0,
    suggestedArchetypes: [],  // AI suggestions
    castDynamics: null,  // AI-analyzed relationships
    warnings: []
  },

  // Goals
  targets: {
    totalWords: 80000,
    dailyWords: 1000,
    currentTotal: 0
  },

  // AI settings
  ai: {
    provider: 'anthropic',  // Global fallback
    model: 'claude-sonnet-4-5',
    batchGeneration: false,

    // Provider configuration per function
    providers: {
      generation: 'anthropic',      // Chapter/scene generation
      continuity: 'anthropic',      // Continuity checks
      analysis: 'anthropic',        // Quality analysis, synopsis
      batchProcessing: 'anthropic', // Batch operations
      characterBuilder: 'anthropic' // Character archetype building
    },

    // Model names per provider (can be customized)
    models: {
      anthropic: 'claude-3-5-sonnet-20241022',
      openai: 'gpt-4-turbo-preview',
      grok: 'grok-2-1212',
      deepseek: 'deepseek-chat'
    },

    // Writing modes
    currentMode: 'production',
    modes: {
      exploration: {
        name: 'Exploration',
        temperature: 0.9,
        maxTokens: 4096,
        systemPrompt: 'Be creative and experimental. Generate multiple variations. Try different approaches.',
        useCase: 'Ideointivaihe, kokeile vaihtoehtoja',
        color: '#B68B5C'
      },
      production: {
        name: 'Production',
        temperature: 0.7,
        maxTokens: 4096,
        systemPrompt: 'Write coherently following the outline and story consistency. Balance creativity with structure.',
        useCase: 'Normaali kirjoitus, seuraa suunnitelmaa',
        color: '#8F7A53'
      },
      polish: {
        name: 'Polish',
        temperature: 0.3,
        maxTokens: 2048,
        systemPrompt: 'Focus on grammar, style consistency, and clarity. Make minimal creative changes. Preserve the author\'s voice.',
        useCase: 'Viimeistely, johdonmukaisuus, kielioppi',
        color: '#715C38'
      }
    },

    costTracking: {
      totalSpent: 0,
      estimatedRemaining: 0,
      tokensUsed: 0,
      requestCount: 0
    }
  },

  // API Configuration
  apiConfig: {
    provider: 'anthropic', // anthropic, openai, local
    anthropic: {
      apiKey: '',
      model: 'claude-sonnet-4-5',
      maxTokens: 4096
    },
    openai: {
      apiKey: '',
      model: 'gpt-4',
      maxTokens: 4096
    },
    local: {
      endpoint: 'http://localhost:1234',
      model: 'local-model'
    },
    lastTested: null,
    isConfigured: false
  }
});

// Story Complexity Analyzer
const ComplexityAnalyzer = {
  analyze(project) {
    const wordCount = project.structure.reduce((sum, ch) => sum + (ch.wordCount || 0), 0);

    const allCharacters = new Set();
    project.structure.forEach(ch => {
      if (ch.notesAI?.characterMentions) {
        ch.notesAI.characterMentions.forEach(name => allCharacters.add(name));
      }
    });
    const characterCount = allCharacters.size || project.characters?.length || 0;

    const plotThreadCount = project.plotThreads
      ? Object.keys(project.plotThreads).length
      : this.estimatePlotThreads(project);

    const timelineCount = this.detectTimelineCount(project);
    const hasNonLinear = this.detectNonLinearStructure(project);

    const score =
      (wordCount / 1000) * 0.3 +
      characterCount * 2 +
      plotThreadCount * 3 +
      timelineCount * 5 +
      (hasNonLinear ? 10 : 0);

    const phase = this.recommendPhase(score);

    return {
      wordCount,
      characterCount,
      plotThreadCount,
      timelineCount,
      hasNonLinear,
      score: Math.round(score),
      phase,
      recommendation: this.getRecommendation(phase, score)
    };
  },

  estimatePlotThreads(project) {
    const themes = new Set();
    project.structure.forEach(ch => {
      if (ch.notesAI?.themes) {
        ch.notesAI.themes.forEach(theme => themes.add(theme));
      }
    });
    return Math.max(1, Math.floor(themes.size * 0.5));
  },

  detectTimelineCount(project) {
    const timeKeywords = {
      past: /aikaisemmin|aiemmin|silloin|muinoin|nuorena|lapsuudessa/i,
      future: /tulevaisuudessa|my√∂hemmin|jonain p√§iv√§n√§|tulee|aikoo/i,
      parallel: /samaan aikaan|samalla hetkell√§|meanwhile|sill√§ v√§lin/i
    };

    let timelines = 1;
    let hasPast = false, hasFuture = false, hasParallel = false;

    project.structure.forEach(ch => {
      const text = (ch.synopsis || '') + ' ' + (ch.notesAI?.timeframe || '');
      if (timeKeywords.past.test(text)) hasPast = true;
      if (timeKeywords.future.test(text)) hasFuture = true;
      if (timeKeywords.parallel.test(text)) hasParallel = true;
    });

    if (hasPast) timelines++;
    if (hasFuture) timelines++;
    if (hasParallel) timelines++;

    return timelines;
  },

  detectNonLinearStructure(project) {
    const nonLinearKeywords = /takaumat|flashback|hypp√§√§ ajassa|muisto|palataan|flash forward/i;
    return project.structure.some(ch => {
      const text = (ch.synopsis || '') + ' ' + (ch.notes || '');
      return nonLinearKeywords.test(text);
    });
  },

  recommendPhase(score) {
    if (score < 30) return 0;
    if (score < 60) return 1;
    if (score < 100) return 2;
    return 3;
  },

  getRecommendation(phase, score) {
    const recommendations = {
      0: {
        title: '‚úÖ Yksinkertainen tarina',
        message: 'Nykyinen j√§rjestelm√§ toimii erinomaisesti.',
        accuracy: '85%',
        action: 'Ei toimenpiteit√§ tarvita.',
        color: '#4CAF50'
      },
      1: {
        title: 'üìä Keskim√§√§r√§inen kompleksisuus',
        message: 'Tarina kasvaa monimutkaisemmaksi.',
        accuracy: '85-90%',
        action: 'Harkitse Phase 1 optimointeja jos havaitset ongelmia.',
        color: '#FF9800'
      },
      2: {
        title: 'üåü Monimutkainen tarina',
        message: 'Suuri hahmojen m√§√§r√§ tai monimutkaiset juonilangat.',
        accuracy: '90-95%',
        action: 'Suositellaan Graph Memory -j√§rjestelm√§√§ (Phase 2).',
        color: '#FF5722'
      },
      3: {
        title: 'üé≠ Eeppinen sarja',
        message: 'Eritt√§in laaja ja monimutkainen teos.',
        accuracy: '95-97%',
        action: 'Harkitse Full Hybrid -j√§rjestelm√§√§ (Phase 3).',
        color: '#9C27B0'
      }
    };
    return recommendations[phase] || recommendations[0];
  }
};

function FAUSTApp() {
  // Project state
  const [project, setProject] = useState(createDefaultProject);
  const [currentFilePath, setCurrentFilePath] = useState(null);
  const [activeChapterId, setActiveChapterId] = useState('chapter-1');
  const [unsavedChanges, setUnsavedChanges] = useState(false);

  // Complexity analysis state
  const [complexity, setComplexity] = useState(null);

  // UI state
  const [isDarkMode, setIsDarkMode] = useState(() => {
    const saved = localStorage.getItem('faust-theme');
    return saved ? saved === 'NOX' : true;
  });
  const [showInspector, setShowInspector] = useState(false);
  const [showCastPlanDialog, setShowCastPlanDialog] = useState(false);
  const [castPlanStep, setCastPlanStep] = useState(1); // 1=input, 2=AI analysis, 3=review
  const [showCharacterBuilder, setShowCharacterBuilder] = useState(false);
  const [selectedCharacterType, setSelectedCharacterType] = useState(null);
  const [characterBuilderStep, setCharacterBuilderStep] = useState(1); // 1=select type, 2=input people, 3=questions, 4=AI gen, 5=review
  const [characterRealPeople, setCharacterRealPeople] = useState('');
  const [characterQuestions, setCharacterQuestions] = useState([]);
  const [characterAnswers, setCharacterAnswers] = useState({});
  const [characterProfile, setCharacterProfile] = useState(null);

  // Voice state
  const [voiceInputAvailable, setVoiceInputAvailable] = useState(false);
  const [voiceState, setVoiceState] = useState('idle'); // idle, listening, processing, error
  const [textSelection, setTextSelection] = useState(null); // { text, start, end }
  const [voiceDiffView, setVoiceDiffView] = useState(null); // { original, revised, instruction }

  // AI Assistant Chat state (Cursor-style)
  const [aiAssistantOpen, setAiAssistantOpen] = useState(false);
  const [aiChatMessages, setAiChatMessages] = useState([]);
  const [aiChatInput, setAiChatInput] = useState('');
  const [aiChatVoiceState, setAiChatVoiceState] = useState('idle');
  const [aiChatProcessing, setAiChatProcessing] = useState(false);
  const [aiSuggestion, setAiSuggestion] = useState(null); // { original, revised, applied }
  const [chatMemory, setChatMemory] = useState({ entries: [], lastUpdated: null });

  // Debug: Log when state changes
  useEffect(() => {
    console.log('[DEBUG] aiAssistantOpen =', aiAssistantOpen);
  }, [aiAssistantOpen]);

  // Settings state
  const [showSettings, setShowSettings] = useState(false);
  const [settingsTab, setSettingsTab] = useState('api'); // api, general, advanced
  const [apiTestResult, setApiTestResult] = useState(null); // {success, message}

  // AI Generation state
  const [isGenerating, setIsGenerating] = useState(false);
  const [generationProgress, setGenerationProgress] = useState(null); // {stage, message}

  // API key input state
  const [showApiKeyInput, setShowApiKeyInput] = useState(null); // null or provider name
  const [apiKeyInputValue, setApiKeyInputValue] = useState('');
  const [apiKeysStatus, setApiKeysStatus] = useState({}); // {anthropic: true, openai: false, ...}

  const editorRef = useRef(null);
  const autosaveTimerRef = useRef(null);
  const voiceInputRef = useRef(null);

  // Get active chapter
  const activeChapter = project.structure.find(ch => ch.id === activeChapterId) || project.structure[0];

  // Apply theme
  useEffect(() => {
    const theme = isDarkMode ? 'NOX' : 'DEIS';
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('faust-theme', theme);
    console.log(`[Theme] ${theme}`);
  }, [isDarkMode]);

  // Load API keys status on mount
  useEffect(() => {
    const loadApiKeysStatus = async () => {
      if (!window.electronAPI) return;

      try {
        const result = await window.electronAPI.loadApiKeys();
        if (result.success && result.keys) {
          const status = {
            anthropic: !!(result.keys.ANTHROPIC_API_KEY),
            openai: !!(result.keys.OPENAI_API_KEY),
            deepseek: !!(result.keys.DEEPSEEK_API_KEY),
            grok: !!(result.keys.GROK_API_KEY)
          };
          setApiKeysStatus(status);
          console.log('[API Keys] Status loaded:', status);
        }
      } catch (error) {
        console.error('[API Keys] Load error:', error);
      }
    };

    loadApiKeysStatus();
  }, []);

  // Update complexity analysis when project changes
  useEffect(() => {
    const analysis = ComplexityAnalyzer.analyze(project);
    setComplexity(analysis);
    console.log('[Complexity] Score:', analysis.score, 'Phase:', analysis.phase);
  }, [project.structure, project.characters]);

  // Update word count and mark unsaved
  const updateChapterContent = (newContent) => {
    const words = newContent.trim().split(/\s+/).filter(w => w.length > 0);

    setProject(prev => ({
      ...prev,
      structure: prev.structure.map(ch =>
        ch.id === activeChapterId
          ? { ...ch, content: newContent, wordCount: words.length }
          : ch
      ),
      targets: {
        ...prev.targets,
        currentTotal: prev.structure.reduce((sum, ch) =>
          sum + (ch.id === activeChapterId ? words.length : ch.wordCount), 0
        )
      }
    }));

    setUnsavedChanges(true);
  };

  // Save project
  const saveProject = async () => {
    if (!window.electronAPI) {
      console.error('[Save] Electron API not available');
      return;
    }

    try {
      const result = await window.electronAPI.saveProject(project);
      if (result.success) {
        setCurrentFilePath(result.path);
        setUnsavedChanges(false);
        console.log('[Save] Project saved:', result.path);
      }
    } catch (error) {
      console.error('[Save] Error:', error);
    }
  };

  // Load project
  const loadProject = async () => {
    if (!window.electronAPI) {
      console.error('[Load] Electron API not available');
      return;
    }

    try {
      const result = await window.electronAPI.loadProject();
      if (result.success) {
        setProject(result.data);
        setCurrentFilePath(result.filePath);
        setActiveChapterId(result.data.structure[0]?.id || 'chapter-1');
        setUnsavedChanges(false);
        console.log('[Load] Project loaded:', result.filePath);
      }
    } catch (error) {
      console.error('[Load] Error:', error);
    }
  };

  // New project
  const newProject = () => {
    if (unsavedChanges) {
      const confirmed = confirm('Tallentamattomat muutokset katoavat. Jatketaanko?');
      if (!confirmed) return;
    }

    setProject(createDefaultProject());
    setCurrentFilePath(null);
    setActiveChapterId('chapter-1');
    setUnsavedChanges(false);
    console.log('[New] New project created');
  };

  // Helper: Create new document with full AI structure
  const createDocument = (type, title, parentId = null) => {
    const timestamp = new Date().toISOString();
    return {
      id: `${type}-${Date.now()}`,
      type,
      title,
      order: 0,
      content: '',
      wordCount: 0,
      children: [],
      parentId,

      // AI-Enhanced Metadata
      synopsis: '',
      synopsisAI: '',
      synopsisManual: '',

      notes: '',
      notesAI: {
        characterMentions: [],
        locations: [],
        timeframe: '',
        mood: '',
        themes: [],
        continuityIssues: []
      },

      status: 'draft',
      aiQuality: {
        score: 0,
        lastAnalyzed: null,
        issues: [],
        strengths: [],
        suggestions: [],
        readiness: 'draft'
      },

      structureHints: {
        shouldBeSplit: false,
        suggestedSceneBreaks: [],
        relatedChapters: [],
        missingTransition: false
      },

      pacing: {
        speed: 'medium',
        tension: 0,
        wordDensity: 0,
        dialogueRatio: 0
      },

      label: '',
      color: '',

      created: timestamp,
      modified: timestamp,

      versions: []
    };
  };

  // Add new chapter
  const addChapter = () => {
    const newChapterNumber = project.structure.length + 1;
    const newChapter = createDocument('chapter', `Luku ${newChapterNumber}`);

    setProject(prev => ({
      ...prev,
      structure: [...prev.structure, newChapter]
    }));

    setActiveChapterId(newChapter.id);
    setUnsavedChanges(true);
    console.log('[Chapter] New chapter added:', newChapter.id);
  };

  // Add new folder (for organizing chapters)
  const addFolder = () => {
    const newFolder = createDocument('folder', 'Uusi kansio');

    setProject(prev => ({
      ...prev,
      structure: [...prev.structure, newFolder]
    }));

    setUnsavedChanges(true);
    console.log('[Folder] New folder added:', newFolder.id);
  };

  // Add scene to chapter
  const addScene = (parentChapterId) => {
    const parent = project.structure.find(ch => ch.id === parentChapterId);
    if (!parent) return;

    const newSceneNumber = (parent.children?.length || 0) + 1;
    const newScene = createDocument('scene', `Kohtaus ${newSceneNumber}`, parentChapterId);

    setProject(prev => ({
      ...prev,
      structure: prev.structure.map(ch =>
        ch.id === parentChapterId
          ? { ...ch, children: [...(ch.children || []), newScene] }
          : ch
      )
    }));

    setActiveChapterId(newScene.id);
    setUnsavedChanges(true);
    console.log('[Scene] New scene added to chapter:', parentChapterId);
  };

  // Delete chapter
  const deleteChapter = (chapterId) => {
    if (project.structure.length === 1) {
      alert('Et voi poistaa viimeist√§ lukua');
      return;
    }

    const confirmed = confirm('Haluatko varmasti poistaa t√§m√§n luvun?');
    if (!confirmed) return;

    const deletedIndex = project.structure.findIndex(ch => ch.id === chapterId);

    setProject(prev => ({
      ...prev,
      structure: prev.structure.filter(ch => ch.id !== chapterId)
    }));

    // Switch to previous chapter or first chapter
    const newActiveId = project.structure[Math.max(0, deletedIndex - 1)]?.id || project.structure[0]?.id;
    setActiveChapterId(newActiveId);
    setUnsavedChanges(true);
    console.log('[Chapter] Deleted:', chapterId);
  };

  // Move chapter up
  const moveChapterUp = (chapterId) => {
    const index = project.structure.findIndex(ch => ch.id === chapterId);
    if (index === 0) return; // Already first

    setProject(prev => {
      const newStructure = [...prev.structure];
      [newStructure[index - 1], newStructure[index]] = [newStructure[index], newStructure[index - 1]];

      // Update order numbers
      newStructure.forEach((ch, idx) => ch.order = idx);

      return { ...prev, structure: newStructure };
    });

    setUnsavedChanges(true);
  };

  // Move chapter down
  const moveChapterDown = (chapterId) => {
    const index = project.structure.findIndex(ch => ch.id === chapterId);
    if (index === project.structure.length - 1) return; // Already last

    setProject(prev => {
      const newStructure = [...prev.structure];
      [newStructure[index], newStructure[index + 1]] = [newStructure[index + 1], newStructure[index]];

      // Update order numbers
      newStructure.forEach((ch, idx) => ch.order = idx);

      return { ...prev, structure: newStructure };
    });

    setUnsavedChanges(true);
  };

  // Change AI mode
  const setAIMode = (modeName) => {
    setProject(prev => ({
      ...prev,
      ai: {
        ...prev.ai,
        currentMode: modeName
      }
    }));
    setUnsavedChanges(true);
    console.log('[AI Mode] Changed to:', modeName);
  };

  // Change AI provider
  const setAIProvider = (providerName) => {
    setProject(prev => ({
      ...prev,
      ai: {
        ...prev.ai,
        provider: providerName
      }
    }));
    setUnsavedChanges(true);
    console.log('[AI Provider] Changed to:', providerName);
  };

  // Toggle API key input for provider
  const toggleApiKeyInput = (providerName) => {
    if (showApiKeyInput === providerName) {
      setShowApiKeyInput(null);
      setApiKeyInputValue('');
    } else {
      setShowApiKeyInput(providerName);
      setApiKeyInputValue('');
    }
  };

  // Save API key
  const saveApiKey = async (providerName, apiKey) => {
    if (!window.electronAPI) {
      alert('Electron API ei k√§ytett√§viss√§');
      return;
    }

    const keyMap = {
      anthropic: 'ANTHROPIC_API_KEY',
      openai: 'OPENAI_API_KEY',
      deepseek: 'DEEPSEEK_API_KEY',
      grok: 'GROK_API_KEY'
    };

    try {
      const result = await window.electronAPI.saveApiKeys({
        [keyMap[providerName]]: apiKey
      });

      if (result.success) {
        console.log('[API Key] Saved for:', providerName);
        setShowApiKeyInput(null);
        setApiKeyInputValue('');

        // Update status
        setApiKeysStatus(prev => ({
          ...prev,
          [providerName]: true
        }));

        alert(`API-avain tallennettu: ${providerName}`);
      } else {
        alert('Virhe tallennuksessa: ' + result.error);
      }
    } catch (error) {
      console.error('[API Key] Save error:', error);
      alert('Virhe tallennuksessa: ' + error.message);
    }
  };

  // Get current mode config
  const getCurrentMode = () => {
    return project.ai.modes[project.ai.currentMode] || project.ai.modes.production;
  };

  // AI Cast Analysis
  const analyzeCast = async (characterTypes) => {
    if (!window.electronAPI) {
      console.error('[AI] Electron API not available');
      return null;
    }

    const prompt = `You are a character psychologist analyzing a book's cast.

The author wants these character types:
${characterTypes.map((type, idx) => `${idx + 1}. ${type}`).join('\n')}

For each character type, suggest:
1. Archetypal family (e.g., "The Sage/Hermit", "The Innocent/Crusader")
2. 3-4 real-world examples (historical figures, authors, etc.)
3. Function in story
4. What they balance against (other characters)
5. Potential flaws

Also analyze:
- Cast dynamics (conflicts, triangles)
- Warnings (e.g., "too dark", "missing gender balance")

Return ONLY valid JSON (no markdown, no extra text):
{
  "suggestions": [
    {
      "type": "character type from input",
      "archetypeFamily": "The Sage/Hermit",
      "examples": ["Marcus Aurelius", "Epictetus", "Miyamoto Musashi"],
      "functionInStory": "Mentor who teaches through detachment",
      "balances": "Young idealist (emotion vs reason)",
      "flaws": "Emotional unavailability, rigidity"
    }
  ],
  "dynamics": {
    "conflicts": ["description of key conflicts"],
    "triangles": [
      {"name": "triangle name", "members": ["char1", "char2", "char3"], "dynamic": "description"}
    ]
  },
  "warnings": ["warning messages"]
}`;

    try {
      console.log('[AI] Analyzing cast...');
      const result = await window.electronAPI.claudeAPI(prompt);

      if (result.success) {
        try {
          // Try to parse response
          let data = result.data;

          // Remove markdown code blocks if present
          data = data.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();

          return JSON.parse(data);
        } catch (parseError) {
          console.error('[AI] Failed to parse JSON:', parseError);
          console.log('[AI] Raw response:', result.data);

          // Try to extract JSON from response
          const jsonMatch = result.data.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            return JSON.parse(jsonMatch[0]);
          }
          return null;
        }
      } else {
        console.error('[AI] API error:', result.error);
        alert('AI-virhe: ' + result.error);
        return null;
      }
    } catch (error) {
      console.error('[AI] Exception:', error);
      alert('AI-virhe: ' + error.message);
      return null;
    }
  };

  // AI Editor Analysis - Analyze chapter/scene content
  const analyzeChapterContent = async (chapterId) => {
    if (!window.electronAPI) {
      console.error('[AI Editor] Electron API not available');
      return null;
    }

    const chapter = project.structure.find(ch => ch.id === chapterId);
    if (!chapter || !chapter.content || chapter.content.trim().length < 50) {
      console.log('[AI Editor] Chapter too short to analyze');
      return null;
    }

    const prompt = `You are an expert writing analyst. Analyze this text comprehensively.

TEXT:
${chapter.content}

PROJECT CONTEXT:
- Characters: ${project.characters.map(c => c.name).join(', ')}
- Genre: ${project.genre}

Provide detailed analysis in JSON format:
{
  "synopsis": "Brief 2-3 sentence summary",
  "notesAI": {
    "characterMentions": ["character names found"],
    "locations": ["places mentioned"],
    "timeframe": "when this takes place",
    "mood": "overall emotional tone",
    "themes": ["themes present"],
    "continuityIssues": ["any contradictions or issues"]
  },
  "aiQuality": {
    "score": 7.5,
    "issues": [
      {"type": "pacing", "severity": "medium", "msg": "Middle section drags"},
      {"type": "dialogue", "severity": "low", "msg": "Some dialogue feels unnatural"}
    ],
    "strengths": ["What works well"],
    "suggestions": ["How to improve"],
    "readiness": "draft|needs-revision|ready-for-review|final"
  },
  "structureHints": {
    "shouldBeSplit": false,
    "suggestedSceneBreaks": [],
    "relatedChapters": [],
    "missingTransition": false
  },
  "pacing": {
    "speed": "slow|medium|fast",
    "tension": 7,
    "wordDensity": 15.5,
    "dialogueRatio": 0.35
  }
}

Return ONLY valid JSON.`;

    try {
      console.log('[AI Editor] Analyzing chapter:', chapterId);
      const result = await window.electronAPI.claudeAPI(prompt);

      if (result.success) {
        try {
          let data = result.data.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
          const analysis = JSON.parse(data);

          // Update chapter with AI analysis
          setProject(prev => ({
            ...prev,
            structure: prev.structure.map(ch =>
              ch.id === chapterId
                ? {
                    ...ch,
                    synopsisAI: analysis.synopsis,
                    synopsis: ch.synopsisManual || analysis.synopsis,
                    notesAI: analysis.notesAI,
                    aiQuality: {
                      ...analysis.aiQuality,
                      lastAnalyzed: new Date().toISOString()
                    },
                    structureHints: analysis.structureHints,
                    pacing: analysis.pacing
                  }
                : ch
            )
          }));

          setUnsavedChanges(true);
          console.log('[AI Editor] Analysis complete:', analysis);
          return analysis;
        } catch (parseError) {
          console.error('[AI Editor] Parse error:', parseError);
          const jsonMatch = result.data.match(/\{[\s\S]*\}/);
          if (jsonMatch) return JSON.parse(jsonMatch[0]);
          return null;
        }
      } else {
        console.error('[AI Editor] API error:', result.error);
        return null;
      }
    } catch (error) {
      console.error('[AI Editor] Exception:', error);
      return null;
    }
  };

  // AI Editor - Generate auto-synopsis for chapter
  const generateSynopsis = async (chapterId) => {
    const chapter = project.structure.find(ch => ch.id === chapterId);
    if (!chapter || !chapter.content || chapter.content.trim().length < 50) {
      return 'Tyhj√§ tai liian lyhyt';
    }

    if (!window.electronAPI) return null;

    const prompt = `Summarize this chapter in 2-3 sentences (in Finnish):

${chapter.content}

Return ONLY the summary, no extra text.`;

    try {
      const result = await window.electronAPI.claudeAPI(prompt);
      if (result.success) {
        const synopsis = result.data.trim();

        setProject(prev => ({
          ...prev,
          structure: prev.structure.map(ch =>
            ch.id === chapterId
              ? {
                  ...ch,
                  synopsisAI: synopsis,
                  synopsis: ch.synopsisManual || synopsis
                }
              : ch
          )
        }));

        setUnsavedChanges(true);
        return synopsis;
      }
    } catch (error) {
      console.error('[AI Synopsis] Error:', error);
    }
    return null;
  };

  // AI Editor - Quick quality check (lighter than full analysis)
  const quickQualityCheck = async (chapterId) => {
    const chapter = project.structure.find(ch => ch.id === chapterId);
    if (!chapter || !chapter.content || chapter.content.trim().length < 50) {
      return { score: 0, issues: [], suggestions: [] };
    }

    if (!window.electronAPI) return null;

    const prompt = `Rate this text quality (1-10) and give 1-2 quick improvement suggestions:

${chapter.content.substring(0, 2000)}...

Return JSON: {"score": 7.5, "suggestions": ["suggestion1", "suggestion2"]}`;

    try {
      const result = await window.electronAPI.claudeAPI(prompt);
      if (result.success) {
        let data = result.data.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        const quality = JSON.parse(data);

        setProject(prev => ({
          ...prev,
          structure: prev.structure.map(ch =>
            ch.id === chapterId
              ? {
                  ...ch,
                  aiQuality: {
                    ...ch.aiQuality,
                    score: quality.score,
                    suggestions: quality.suggestions,
                    lastAnalyzed: new Date().toISOString()
                  }
                }
              : ch
          )
        }));

        setUnsavedChanges(true);
        return quality;
      }
    } catch (error) {
      console.error('[AI Quality] Error:', error);
    }
    return null;
  };

  // AI Generate Chapter
  const generateChapter = async (chapterId) => {
    if (!window.electronAPI) {
      console.error('[Generate] Electron API not available');
      return;
    }

    setIsGenerating(true);
    setGenerationProgress({ stage: 'preparing', message: 'Valmistellaan generointia...' });

    try {
      const result = await window.electronAPI.aiGenerateChapter({
        chapterId,
        project,
        mode: project.ai.currentMode,
        provider: project.ai.providers?.generation || project.ai.provider || 'anthropic'
      });

      if (result.success) {
        setGenerationProgress({ stage: 'updating', message: 'P√§ivitet√§√§n sis√§lt√∂√§...' });

        // Update chapter content
        setProject(prev => ({
          ...prev,
          structure: prev.structure.map(ch =>
            ch.id === chapterId
              ? { ...ch, content: result.content, wordCount: result.wordCount }
              : ch
          ),
          targets: {
            ...prev.targets,
            currentTotal: prev.structure.reduce((sum, ch) =>
              sum + (ch.id === chapterId ? result.wordCount : ch.wordCount), 0
            )
          }
        }));

        setUnsavedChanges(true);
        setGenerationProgress({ stage: 'complete', message: `Generoitu ${result.wordCount} sanaa!` });

        console.log('[Generate] Success:', result.wordCount, 'words');

        // Clear progress after 2 seconds
        setTimeout(() => {
          setGenerationProgress(null);
          setIsGenerating(false);
        }, 2000);

      } else {
        console.error('[Generate] Error:', result.error);
        alert('Generointi ep√§onnistui: ' + result.error);
        setGenerationProgress(null);
        setIsGenerating(false);
      }

    } catch (error) {
      console.error('[Generate] Exception:', error);
      alert('Generointi ep√§onnistui: ' + error.message);
      setGenerationProgress(null);
      setIsGenerating(false);
    }
  };

  // Character Builder Phase 2 - Generate clarifying questions
  const generateCharacterQuestions = async (characterType, realPeople, archetypeInfo) => {
    if (!window.electronAPI) {
      console.error('[Character Builder] Electron API not available');
      return null;
    }

    const prompt = `You are a character psychologist helping an author create a detailed fictional character.

CHARACTER TYPE: ${characterType}
ARCHETYPE: ${archetypeInfo.archetypeFamily}
REAL PEOPLE INSPIRATION: ${realPeople}

Based on the cast analysis, this character:
- Function: ${archetypeInfo.functionInStory}
- Examples: ${archetypeInfo.examples.join(', ')}
- Potential flaws: ${archetypeInfo.flaws}

Generate 5-7 clarifying questions to help define this character's unique traits.
Questions should explore:
1. Core motivation (what drives them?)
2. Shadow aspects (hidden darkness, Jung's shadow)
3. Relationships (how do they relate to others?)
4. Voice & mannerisms (how do they speak/act?)
5. Transformation arc (how might they change?)

Return ONLY valid JSON:
{
  "questions": [
    {
      "id": 1,
      "category": "motivation",
      "question": "What is this character's deepest fear?"
    },
    ...
  ]
}`;

    try {
      console.log('[Character Builder] Generating questions...');
      const result = await window.electronAPI.claudeAPI(prompt);

      if (result.success) {
        try {
          let data = result.data.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
          return JSON.parse(data);
        } catch (parseError) {
          console.error('[Character Builder] Parse error:', parseError);
          const jsonMatch = result.data.match(/\{[\s\S]*\}/);
          if (jsonMatch) return JSON.parse(jsonMatch[0]);
          return null;
        }
      } else {
        console.error('[Character Builder] API error:', result.error);
        alert('AI-virhe: ' + result.error);
        return null;
      }
    } catch (error) {
      console.error('[Character Builder] Exception:', error);
      alert('Hahmovirhe: ' + error.message);
      return null;
    }
  };

  // Character Builder Phase 2 - Generate full profile
  const generateCharacterProfile = async (characterType, realPeople, archetypeInfo, answers) => {
    if (!window.electronAPI) {
      console.error('[Character Builder] Electron API not available');
      return null;
    }

    const answersText = Object.entries(answers)
      .map(([qId, answer]) => `Q${qId}: ${answer}`)
      .join('\n');

    const prompt = `You are a master character designer creating a deep psychological profile.

CHARACTER TYPE: ${characterType}
ARCHETYPE: ${archetypeInfo.archetypeFamily}
REAL PEOPLE INSPIRATION: ${realPeople}

AUTHOR'S ANSWERS:
${answersText}

Create a comprehensive character profile including:
1. Basic info (name suggestion, age range, appearance)
2. Psychology (MBTI, Enneagram, dominant traits)
3. Shadow work (Jungian shadow, suppressed aspects)
4. Motivation & goals (surface + hidden)
5. Relationships (how they relate to others)
6. Voice & speech patterns (3-4 example lines in character)
7. Transformation arc (beginning ‚Üí end state)
8. Key scenes (3-4 defining moments)

Return ONLY valid JSON:
{
  "name": "Suggested name",
  "age": "40-55",
  "appearance": "Brief description",
  "psychology": {
    "mbti": "INTJ",
    "enneagram": "5w4",
    "traits": ["trait1", "trait2", "trait3"]
  },
  "shadow": {
    "hidden": "What they hide",
    "fear": "Deepest fear",
    "desire": "Secret desire"
  },
  "motivation": {
    "surface": "What they claim",
    "hidden": "What actually drives them"
  },
  "voice": {
    "style": "Description of speech patterns",
    "examples": ["Example line 1", "Example line 2", "Example line 3"]
  },
  "arc": {
    "beginning": "Starting state",
    "catalyst": "What changes them",
    "end": "Final transformation"
  },
  "keyScenes": [
    {"title": "Scene name", "description": "What happens"}
  ]
}`;

    try {
      console.log('[Character Builder] Generating profile...');
      const result = await window.electronAPI.claudeAPI(prompt);

      if (result.success) {
        try {
          let data = result.data.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
          const profile = JSON.parse(data);

          // Add metadata
          profile.characterType = characterType;
          profile.realPeopleInspiration = realPeople;
          profile.archetype = archetypeInfo;
          profile.created = new Date().toISOString();

          return profile;
        } catch (parseError) {
          console.error('[Character Builder] Parse error:', parseError);
          const jsonMatch = result.data.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            const profile = JSON.parse(jsonMatch[0]);
            profile.characterType = characterType;
            profile.realPeopleInspiration = realPeople;
            profile.archetype = archetypeInfo;
            profile.created = new Date().toISOString();
            return profile;
          }
          return null;
        }
      } else {
        console.error('[Character Builder] API error:', result.error);
        alert('AI-virhe: ' + result.error);
        return null;
      }
    } catch (error) {
      console.error('[Character Builder] Exception:', error);
      alert('Profiilivirhe: ' + error.message);
      return null;
    }
  };

  // API Settings - Handler functions
  const updateApiKey = (provider, key) => {
    setProject(prev => ({
      ...prev,
      apiConfig: {
        ...prev.apiConfig,
        [provider]: {
          ...prev.apiConfig[provider],
          apiKey: key
        },
        isConfigured: key.trim().length > 0
      }
    }));
    setUnsavedChanges(true);
    setApiTestResult(null); // Clear previous test result
    console.log('[API] Updated key for:', provider);
  };

  const setActiveApiProvider = (provider) => {
    setProject(prev => ({
      ...prev,
      apiConfig: {
        ...prev.apiConfig,
        provider
      }
    }));
    setUnsavedChanges(true);
    console.log('[API] Active provider changed to:', provider);
  };

  const testApiConnection = async () => {
    const provider = project.apiConfig.provider;
    const config = project.apiConfig[provider];

    if (!config.apiKey || config.apiKey.trim().length === 0) {
      setApiTestResult({
        success: false,
        message: 'API-avain puuttuu. Sy√∂t√§ avain ensin.'
      });
      return;
    }

    setApiTestResult({ success: null, message: 'Testataan yhteytt√§...' });

    try {
      // Test with a simple prompt
      const testPrompt = 'Respond with exactly: "API connection successful"';

      if (!window.electronAPI) {
        setApiTestResult({
          success: false,
          message: 'Electron API ei saatavilla'
        });
        return;
      }

      const result = await window.electronAPI.claudeAPI(testPrompt);

      if (result.success) {
        setProject(prev => ({
          ...prev,
          apiConfig: {
            ...prev.apiConfig,
            lastTested: new Date().toISOString(),
            isConfigured: true
          }
        }));

        setApiTestResult({
          success: true,
          message: `‚úì Yhteys toimii! Model: ${config.model}`
        });
      } else {
        setApiTestResult({
          success: false,
          message: `Virhe: ${result.error || 'Tuntematon virhe'}`
        });
      }
    } catch (error) {
      setApiTestResult({
        success: false,
        message: `Yhteysvirhe: ${error.message}`
      });
    }
  };

  // Character Builder - Handler functions
  const startCharacterBuilder = (characterType) => {
    const typeIndex = project.castPlan.characterTypes.indexOf(characterType);
    const archetypeInfo = project.castPlan.suggestedArchetypes[typeIndex];

    setSelectedCharacterType({ type: characterType, archetype: archetypeInfo });
    setCharacterBuilderStep(2);
    setShowCharacterBuilder(true);
    console.log('[Character Builder] Started for:', characterType);
  };

  const handleCharacterPeopleSubmit = async () => {
    if (!characterRealPeople.trim()) {
      alert('Sy√∂t√§ v√§hint√§√§n yksi henkil√∂ (esim. "Ernst J√ºnger + C.G. Jung")');
      return;
    }

    // Move to step 3 (AI generates questions)
    setCharacterBuilderStep(3);

    const questions = await generateCharacterQuestions(
      selectedCharacterType.type,
      characterRealPeople,
      selectedCharacterType.archetype
    );

    if (questions && questions.questions) {
      setCharacterQuestions(questions.questions);
      setCharacterBuilderStep(4); // Move to questions step
    } else {
      alert('Kysymysten generointi ep√§onnistui');
      setCharacterBuilderStep(2);
    }
  };

  const handleCharacterAnswersSubmit = async () => {
    // Check if all questions are answered
    const unanswered = characterQuestions.filter(q => !characterAnswers[q.id] || !characterAnswers[q.id].trim());

    if (unanswered.length > 0) {
      const confirmed = confirm(
        `${unanswered.length} kysymyst√§ vastausta. Jatketaanko silti?\n\n` +
        `Paremmat vastaukset = parempi hahmo.`
      );
      if (!confirmed) return;
    }

    // Move to step 5 (AI generates profile)
    setCharacterBuilderStep(5);

    const profile = await generateCharacterProfile(
      selectedCharacterType.type,
      characterRealPeople,
      selectedCharacterType.archetype,
      characterAnswers
    );

    if (profile) {
      setCharacterProfile(profile);
      setCharacterBuilderStep(6); // Move to review step
    } else {
      alert('Profiilin generointi ep√§onnistui');
      setCharacterBuilderStep(4);
    }
  };

  const saveCharacterProfile = () => {
    if (!characterProfile) return;

    setProject(prev => ({
      ...prev,
      characters: [...prev.characters, characterProfile]
    }));

    // Reset builder
    setShowCharacterBuilder(false);
    setCharacterBuilderStep(1);
    setSelectedCharacterType(null);
    setCharacterRealPeople('');
    setCharacterQuestions([]);
    setCharacterAnswers({});
    setCharacterProfile(null);
    setUnsavedChanges(true);

    console.log('[Character Builder] Profile saved:', characterProfile.name);
  };

  const cancelCharacterBuilder = () => {
    const confirmed = confirm('Haluatko varmasti peruuttaa? Kaikki sy√∂tetyt tiedot katoavat.');
    if (!confirmed) return;

    setShowCharacterBuilder(false);
    setCharacterBuilderStep(1);
    setSelectedCharacterType(null);
    setCharacterRealPeople('');
    setCharacterQuestions([]);
    setCharacterAnswers({});
    setCharacterProfile(null);
  };

  // Voice Edit Selected Text
  const editByVoice = async (selectedText, voiceInstruction) => {
    if (!window.electronAPI) {
      console.error('[Voice] Electron API not available');
      return null;
    }

    const currentMode = getCurrentMode();

    const prompt = `ORIGINAL TEXT:
${selectedText}

USER INSTRUCTION (spoken):
"${voiceInstruction}"

TASK:
Rewrite the text following the instruction.
Preserve the general meaning but apply the requested change.
${currentMode.systemPrompt}

Return ONLY the rewritten text, no explanations or extra commentary.`;

    try {
      console.log('[Voice] Sending to AI...');
      setVoiceState('processing');

      const result = await window.electronAPI.claudeAPI(prompt);

      if (result.success) {
        console.log('[Voice] AI response received');
        setVoiceState('idle');
        return {
          original: selectedText,
          revised: result.data.trim(),
          instruction: voiceInstruction
        };
      } else {
        console.error('[Voice] AI error:', result.error);
        alert('AI-virhe: ' + result.error);
        setVoiceState('error');
        return null;
      }
    } catch (error) {
      console.error('[Voice] Exception:', error);
      alert('√Ñ√§nivirhe: ' + error.message);
      setVoiceState('error');
      return null;
    }
  };

  // Handle voice command for selected text
  const handleVoiceEdit = async () => {
    if (!textSelection || !textSelection.text.trim()) {
      alert('Ei valittua teksti√§. Valitse ensin teksti jota haluat muuttaa.');
      return;
    }

    if (!voiceInputRef.current) {
      alert('√Ñ√§nisy√∂te ei ole k√§ytett√§viss√§ t√§ss√§ selaimessa.');
      return;
    }

    try {
      setVoiceState('listening');
      console.log('[Voice] Listening for instruction...');

      const result = await voiceInputRef.current.listen();

      if (result && result.transcript) {
        console.log('[Voice] Heard:', result.transcript);

        if (result.confidence < 0.5) {
          const confirmed = confirm(
            `Kuulin: "${result.transcript}"\n\n` +
            `Luotettavuus alhainen (${Math.round(result.confidence * 100)}%). Jatketaanko?`
          );
          if (!confirmed) {
            setVoiceState('idle');
            return;
          }
        }

        // Send to AI
        const diffResult = await editByVoice(textSelection.text, result.transcript);

        if (diffResult) {
          setVoiceDiffView(diffResult);
        }
      }
    } catch (error) {
      console.error('[Voice] Error:', error);
      alert(error.message);
      setVoiceState('error');
      setTimeout(() => setVoiceState('idle'), 2000);
    }
  };

  // Accept voice edit
  const acceptVoiceEdit = () => {
    if (!voiceDiffView) return;

    // Replace selected text with AI-generated text
    const content = activeChapter.content;
    const before = content.substring(0, textSelection.start);
    const after = content.substring(textSelection.end);
    const newContent = before + voiceDiffView.revised + after;

    updateChapterContent(newContent);

    // Clear diff view and selection
    setVoiceDiffView(null);
    setTextSelection(null);
    console.log('[Voice] Edit accepted');
  };

  // Reject voice edit
  const rejectVoiceEdit = () => {
    setVoiceDiffView(null);
    console.log('[Voice] Edit rejected');
  };

  // Track text selection in editor
  const handleTextSelection = () => {
    if (!editorRef.current) return;

    const textarea = editorRef.current;
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;

    if (start !== end) {
      const selectedText = textarea.value.substring(start, end);
      setTextSelection({ text: selectedText, start, end });
      console.log('[Voice] Text selected:', selectedText.substring(0, 50) + '...');
    } else {
      setTextSelection(null);
    }
  };

  // AI Chat - Send message (text or voice)
  const sendAiChatMessage = async (message) => {
    if (!message || !message.trim()) return;
    if (!window.electronAPI) {
      console.error('[AI Chat] Electron API not available');
      return;
    }

    const userMessage = message.trim();

    // Add user message to history
    setAiChatHistory(prev => [...prev, { role: 'user', content: userMessage }]);
    setAiChatInput('');

    // Build context-aware prompt
    const currentMode = getCurrentMode();
    const prompt = `You are FAUST AI, an intelligent writing assistant helping a Finnish author.

CONTEXT:
- Project: ${project.title}
- Current chapter: ${activeChapter.title}
- AI Mode: ${project.ai.currentMode} (${currentMode.useCase})
- Words written: ${project.targets.currentTotal} / ${project.targets.totalWords}

USER QUESTION:
${userMessage}

Respond helpfully and concisely. If the question is about the current chapter, you can reference it. Keep responses focused and actionable.`;

    try {
      console.log('[AI Chat] Sending message...');
      setAiChatVoiceState('processing');

      const result = await window.electronAPI.claudeAPI(prompt);

      if (result.success) {
        console.log('[AI Chat] Response received');
        setAiChatHistory(prev => [...prev, { role: 'assistant', content: result.data.trim() }]);
        setAiChatVoiceState('idle');
      } else {
        console.error('[AI Chat] AI error:', result.error);
        setAiChatHistory(prev => [...prev, { role: 'error', content: 'Virhe: ' + result.error }]);
        setAiChatVoiceState('error');
      }
    } catch (error) {
      console.error('[AI Chat] Exception:', error);
      setAiChatHistory(prev => [...prev, { role: 'error', content: 'Virhe: ' + error.message }]);
      setAiChatVoiceState('error');
    }
  };

  // AI Chat - Voice input
  const handleAiChatVoice = async () => {
    if (!voiceInputRef.current) {
      alert('√Ñ√§nisy√∂te ei ole k√§ytett√§viss√§ t√§ss√§ selaimessa.');
      return;
    }

    try {
      setAiChatVoiceState('listening');
      console.log('[AI Chat Voice] Listening...');

      const result = await voiceInputRef.current.listen();

      if (result && result.transcript) {
        console.log('[AI Chat Voice] Heard:', result.transcript);

        if (result.confidence < 0.5) {
          const confirmed = confirm(
            `Kuulin: "${result.transcript}"\n\n` +
            `Luotettavuus alhainen (${Math.round(result.confidence * 100)}%). Jatketaanko?`
          );
          if (!confirmed) {
            setAiChatVoiceState('idle');
            return;
          }
        }

        // Send voice message to AI
        await sendAiChatMessage(result.transcript);
      }
    } catch (error) {
      console.error('[AI Chat Voice] Error:', error);
      alert(error.message);
      setAiChatVoiceState('error');
      setTimeout(() => setAiChatVoiceState('idle'), 2000);
    }
  };

  // AI Assistant Panel - Send message with model selection
  const sendAiAssistantMessage = async () => {
    if (!aiChatInput.trim()) return;
    if (!window.electronAPI) {
      console.error('[AI Assistant] Electron API not available');
      return;
    }

    const userMessage = aiChatInput.trim();
    const selectedText = textSelection?.text || '';

    // Add user message to chat
    setAiChatMessages(prev => [...prev, { role: 'user', content: userMessage, selectedText }]);
    setAiChatInput('');
    setAiChatProcessing(true);

    // Build memory context from recent important decisions
    const memoryContext = chatMemory.entries
      .filter(e => e.type === 'decision' || e.type === 'direction')
      .slice(-5)
      .map(e => `- ${e.summary}`)
      .join('\n');

    // Build context-aware prompt
    const currentMode = getCurrentMode();
    const contextPrompt = selectedText
      ? `The user has selected this text:\n"""${selectedText}"""\n\nUser instruction: ${userMessage}\n\nPlease provide a revised version of the selected text based on the instruction.`
      : `User question: ${userMessage}\n\nRespond helpfully about their writing project.`;

    const fullPrompt = `You are FAUST AI Assistant (Liminal Engine), helping with creative writing.

PROJECT CONTEXT:
- Title: ${project.title}
- Current chapter: ${activeChapter.title}
- AI Mode: ${project.ai.currentMode} (${currentMode.useCase})
- Progress: ${project.targets.currentTotal} / ${project.targets.totalWords} words

${memoryContext ? `RECENT DECISIONS & DIRECTIONS:\n${memoryContext}\n` : ''}
${contextPrompt}`;

    try {
      // Get selected provider and model
      const provider = project.ai.provider || 'anthropic';
      const modelName = project.ai.models?.[provider] ||
        (provider === 'anthropic' ? 'claude-3-5-sonnet-20241022' :
         provider === 'openai' ? 'gpt-4-turbo-preview' :
         provider === 'grok' ? 'grok-2-1212' : 'deepseek-chat');

      let result;
      // Call appropriate API based on provider
      if (provider === 'anthropic') {
        result = await window.electronAPI.claudeAPI({ prompt: fullPrompt, model: modelName });
      } else if (provider === 'openai') {
        result = await window.electronAPI.openaiAPI({ prompt: fullPrompt, model: modelName });
      } else if (provider === 'grok') {
        result = await window.electronAPI.grokAPI({ prompt: fullPrompt, model: modelName });
      } else if (provider === 'deepseek') {
        result = await window.electronAPI.deepseekAPI({ prompt: fullPrompt, model: modelName });
      }

      if (result?.success) {
        const responseText = result.data.trim();
        setAiChatMessages(prev => [...prev, { role: 'assistant', content: responseText }]);

        // Save to chat memory if it's about decisions or directions
        const isImportant = userMessage.toLowerCase().match(
          /decide|plan|direction|character|plot|theme|structure|approach|strategy|goal|want to|should|going to/
        );

        if (isImportant && window.electronAPI.saveChatMemory) {
          await window.electronAPI.saveChatMemory({
            type: 'decision',
            summary: userMessage.length > 100 ? userMessage.substring(0, 97) + '...' : userMessage,
            userMessage,
            aiResponse: responseText.substring(0, 200),
            project: project.title,
            chapter: activeChapter.title
          });
          console.log('[Chat Memory] Saved important message');
        }

        // If there was selected text, show as suggestion
        if (selectedText) {
          setAiSuggestion({
            original: selectedText,
            revised: responseText,
            applied: false
          });
        }
      } else {
        setAiChatMessages(prev => [...prev, { role: 'error', content: 'Virhe: ' + (result?.error || 'Unknown error') }]);
      }
    } catch (error) {
      console.error('[AI Assistant] Error:', error);
      setAiChatMessages(prev => [...prev, { role: 'error', content: 'Virhe: ' + error.message }]);
    } finally {
      setAiChatProcessing(false);
    }
  };

  // AI Assistant - Voice input
  const handleAiAssistantVoice = async () => {
    if (!voiceInputRef.current) {
      alert('√Ñ√§nisy√∂te ei ole k√§ytett√§viss√§ t√§ss√§ selaimessa.');
      return;
    }

    try {
      setAiChatVoiceState('listening');
      console.log('[AI Assistant Voice] Listening...');

      const result = await voiceInputRef.current.listen();

      if (result && result.transcript) {
        console.log('[AI Assistant Voice] Heard:', result.transcript);

        if (result.confidence < 0.5) {
          const confirmed = confirm(
            `Kuulin: "${result.transcript}"\n\n` +
            `Luotettavuus alhainen (${Math.round(result.confidence * 100)}%). Jatketaanko?`
          );
          if (!confirmed) {
            setAiChatVoiceState('idle');
            return;
          }
        }

        // Set the transcript as input and send
        setAiChatInput(result.transcript);
        setAiChatVoiceState('idle');
      } else {
        setAiChatVoiceState('idle');
      }
    } catch (error) {
      console.error('[AI Assistant Voice] Error:', error);
      alert(error.message);
      setAiChatVoiceState('error');
      setTimeout(() => setAiChatVoiceState('idle'), 2000);
    }
  };

  // AI Assistant - Apply suggestion
  const applyAiSuggestion = () => {
    if (!aiSuggestion || !textSelection) return;

    const textarea = document.getElementById('chapter-content-editor');
    if (!textarea) return;

    const content = activeChapter.content;
    const newContent = content.substring(0, textSelection.start) +
                       aiSuggestion.revised +
                       content.substring(textSelection.end);

    setProject(prev => ({
      ...prev,
      structure: prev.structure.map(ch =>
        ch.id === activeChapter.id ? { ...ch, content: newContent } : ch
      )
    }));

    setAiSuggestion({ ...aiSuggestion, applied: true });
    setTextSelection(null);
    setUnsavedChanges(true);
  };

  // Load chat memory on mount
  useEffect(() => {
    const loadMemory = async () => {
      if (window.electronAPI?.loadChatMemory) {
        const result = await window.electronAPI.loadChatMemory();
        if (result.success) {
          setChatMemory(result.data);
          console.log('[Chat Memory] Loaded', result.data.entries?.length || 0, 'entries');
        }
      }
    };
    loadMemory();
  }, []);

  // Initialize voice input on mount
  useEffect(() => {
    // Check browser support
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

    if (SpeechRecognition) {
      // Dynamically load VoiceInput class
      const script = document.createElement('script');
      script.src = './src/utils/voiceInput.js';
      script.onerror = (err) => {
        console.error('[Voice] Failed to load voiceInput.js:', err);
      };
      script.onload = () => {
        try {
          // VoiceInput is now globally available
          if (window.VoiceInput) {
            const voiceInput = new window.VoiceInput('fi-FI');
            voiceInput.onStateChange = (state) => {
              console.log('[Voice] State change:', state);
              if (state === 'listening') setVoiceState('listening');
              else if (state === 'idle') setVoiceState('idle');
            };
            voiceInputRef.current = voiceInput;
            setVoiceInputAvailable(true);
            console.log('[Voice] Voice input initialized');

            const browserWarning = window.VoiceInput.getBrowserRecommendation();
            if (browserWarning) {
              console.warn('[Voice]', browserWarning);
            }
          }
        } catch (error) {
          console.error('[Voice] Failed to initialize:', error);
        }
      };
      document.head.appendChild(script);
    } else {
      console.warn('[Voice] Web Speech API not supported');
    }
  }, []);

  // Autosave
  useEffect(() => {
    if (!unsavedChanges || !currentFilePath || !window.electronAPI) {
      return;
    }

    // Clear existing timer
    if (autosaveTimerRef.current) {
      clearTimeout(autosaveTimerRef.current);
    }

    // Set new timer (30 seconds)
    autosaveTimerRef.current = setTimeout(async () => {
      try {
        const result = await window.electronAPI.autosaveProject({
          projectData: project,
          filePath: currentFilePath
        });

        if (result.success) {
          setUnsavedChanges(false);
          console.log('[Autosave] Project autosaved');
        }
      } catch (error) {
        console.error('[Autosave] Error:', error);
      }
    }, 30000);

    return () => {
      if (autosaveTimerRef.current) {
        clearTimeout(autosaveTimerRef.current);
      }
    };
  }, [unsavedChanges, currentFilePath, project]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e) => {
      // Cmd+S = Save
      if (e.metaKey && e.key === 's') {
        e.preventDefault();
        saveProject();
      }
      // Cmd+O = Open
      if (e.metaKey && e.key === 'o') {
        e.preventDefault();
        loadProject();
      }
      // Cmd+N = New Project
      if (e.metaKey && e.key === 'n') {
        e.preventDefault();
        newProject();
      }
      // Cmd+I = Toggle Inspector
      if (e.metaKey && e.key === 'i') {
        e.preventDefault();
        setShowInspector(prev => !prev);
      }
      // Cmd+Shift+D = Toggle Theme
      if (e.metaKey && e.shiftKey && e.key === 'd') {
        e.preventDefault();
        setIsDarkMode(prev => !prev);
      }
      // Cmd+K = Toggle AI Assistant
      if (e.metaKey && e.key === 'k') {
        e.preventDefault();
        console.log('[Liminal Engine] Toggle:', !aiAssistantOpen);
        setAiAssistantOpen(prev => !prev);
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [project, unsavedChanges, currentFilePath, aiAssistantOpen]);

  return e('div', { className: 'faust-app' },
    // Header
    e('div', { className: 'faust-header' },
      e('div', { style: { padding: '16px', paddingLeft: '80px', color: 'var(--text)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' } },
        e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px' } },
          // FAUST with 8-pointed star
          e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' } },
            e('span', { style: { fontFamily: 'EB Garamond', fontSize: '18px', fontWeight: 600 } }, 'FAUST'),
            // 8-pointed chaos star - adapts to NOX/DEIS theme
            e('svg', {
              xmlns: 'http://www.w3.org/2000/svg',
              width: '18',
              height: '18',
              viewBox: '0 0 100 100',
              style: { opacity: 0.75, color: 'var(--ink)', display: 'block' }
            },
              e('path', {
                d: 'M 50,2 L 58,31 L 84,16 L 69,42 L 98,50 L 69,58 L 84,84 L 58,69 L 50,98 L 42,69 L 16,84 L 31,58 L 2,50 L 31,42 L 16,16 L 42,31 Z',
                fill: 'currentColor'
              })
            )
          ),
          e('span', { style: { fontFamily: 'IBM Plex Mono', fontSize: '12px', color: 'var(--text-2)' } },
            project.title + (unsavedChanges ? ' ‚Ä¢' : ''))
        ),
        e('div', { style: { display: 'flex', gap: '8px' } },
          e('button', {
            onClick: newProject,
            title: 'Uusi projekti (Cmd+N)',
            style: {
              background: 'transparent',
              border: '1px solid var(--border-color)',
              color: 'var(--text)',
              padding: '4px 12px',
              borderRadius: '4px',
              cursor: 'pointer',
              fontFamily: 'IBM Plex Mono',
              fontSize: '12px'
            }
          }, 'Uusi'),
          e('button', {
            onClick: loadProject,
            title: 'Avaa projekti (Cmd+O)',
            style: {
              background: 'transparent',
              border: '1px solid var(--border-color)',
              color: 'var(--text)',
              padding: '4px 12px',
              borderRadius: '4px',
              cursor: 'pointer',
              fontFamily: 'IBM Plex Mono',
              fontSize: '12px'
            }
          }, 'Avaa'),
          e('button', {
            onClick: saveProject,
            title: 'Tallenna projekti (Cmd+S)',
            style: {
              background: unsavedChanges ? 'var(--bronze)' : 'transparent',
              border: '1px solid var(--border-color)',
              color: 'var(--text)',
              padding: '4px 12px',
              borderRadius: '4px',
              cursor: 'pointer',
              fontFamily: 'IBM Plex Mono',
              fontSize: '12px'
            }
          }, 'Tallenna'),
          e('button', {
            onClick: () => setIsDarkMode(prev => !prev),
            style: {
              background: 'transparent',
              border: '1px solid var(--border-color)',
              color: 'var(--text)',
              padding: '4px 12px',
              borderRadius: '4px',
              cursor: 'pointer',
              fontFamily: 'IBM Plex Mono',
              fontSize: '12px'
            }
          }, isDarkMode ? 'NOX' : 'DEIS'),
          e('button', {
            onClick: () => setShowInspector(prev => !prev),
            style: {
              background: 'transparent',
              border: '1px solid var(--border-color)',
              color: 'var(--text)',
              padding: '4px 12px',
              borderRadius: '4px',
              cursor: 'pointer',
              fontFamily: 'IBM Plex Mono',
              fontSize: '12px'
            }
          }, showInspector ? 'Piilota' : 'Inspector'),
          e('button', {
            onClick: () => {
              console.log('[DEBUG] Button clicked, toggling from', aiAssistantOpen, 'to', !aiAssistantOpen);
              setAiAssistantOpen(prev => !prev);
            },
            style: {
              background: aiAssistantOpen ? 'var(--gold)' : 'transparent',
              border: '1px solid var(--border-color)',
              color: aiAssistantOpen ? '#000' : 'var(--text)',
              padding: '4px 12px',
              borderRadius: '4px',
              cursor: 'pointer',
              fontFamily: 'IBM Plex Mono',
              fontSize: '12px',
              fontWeight: aiAssistantOpen ? 600 : 400
            }
          }, 'Liminal'),
          e('button', {
            onClick: () => setShowSettings(true),
            style: {
              background: project.apiConfig.isConfigured ? 'transparent' : 'var(--bronze)',
              border: '1px solid var(--border-color)',
              color: project.apiConfig.isConfigured ? 'var(--text)' : '#000',
              padding: '4px 12px',
              borderRadius: '4px',
              cursor: 'pointer',
              fontFamily: 'IBM Plex Mono',
              fontSize: '12px',
              fontWeight: project.apiConfig.isConfigured ? 400 : 600
            }
          }, '‚öôÔ∏è Asetukset')
        )
      )
    ),

    // Main content - three columns
    e('div', { className: 'faust-main' },
      // Left sidebar - Chapter list
      e('div', { className: 'faust-sidebar' },
        e('div', { style: { padding: '16px', color: 'var(--text)' } },
          e('h3', { style: { fontFamily: 'EB Garamond', fontSize: '16px', marginBottom: '12px' } }, project.title),

          // Project stats
          e('div', {
            style: {
              fontFamily: 'IBM Plex Mono',
              fontSize: '11px',
              color: 'var(--text-3)',
              marginBottom: '16px',
              paddingBottom: '12px',
              borderBottom: '1px solid var(--border-color)'
            }
          },
            e('div', null, `${project.targets.currentTotal} / ${project.targets.totalWords} sanaa`),
            e('div', null, `${project.structure.length} lukua`)
          ),

          // Chapter list
          e('div', { style: { display: 'flex', flexDirection: 'column', gap: '4px', marginBottom: '16px' } },
            project.structure.map((chapter, idx) =>
              e('div', {
                key: chapter.id,
                style: {
                  display: 'flex',
                  alignItems: 'center',
                  gap: '4px',
                  padding: '8px 12px',
                  borderRadius: '4px',
                  background: chapter.id === activeChapterId ? 'var(--bg-tertiary, rgba(143,122,83,0.1))' : 'transparent',
                  borderLeft: chapter.id === activeChapterId ? '2px solid var(--bronze)' : '2px solid transparent',
                  transition: 'all 0.2s'
                }
              },
                // Chapter info (clickable)
                e('div', {
                  onClick: () => setActiveChapterId(chapter.id),
                  style: {
                    flex: 1,
                    cursor: 'pointer',
                    fontFamily: 'IBM Plex Mono',
                    fontSize: '13px',
                    color: chapter.id === activeChapterId ? 'var(--text)' : 'var(--text-2)'
                  }
                },
                  e('div', { style: { marginBottom: '4px' } }, chapter.title),
                  e('div', { style: { fontSize: '11px', color: 'var(--text-3)' } }, `${chapter.wordCount} sanaa`)
                ),

                // Chapter controls (only show for active chapter)
                chapter.id === activeChapterId ? e('div', { style: { display: 'flex', gap: '2px' } },
                  // Move up
                  idx > 0 ? e('button', {
                    onClick: () => moveChapterUp(chapter.id),
                    title: 'Siirr√§ yl√∂s',
                    style: {
                      background: 'transparent',
                      border: 'none',
                      color: 'var(--text-3)',
                      cursor: 'pointer',
                      padding: '2px 4px',
                      fontSize: '14px'
                    }
                  }, '‚Üë') : null,

                  // Move down
                  idx < project.structure.length - 1 ? e('button', {
                    onClick: () => moveChapterDown(chapter.id),
                    title: 'Siirr√§ alas',
                    style: {
                      background: 'transparent',
                      border: 'none',
                      color: 'var(--text-3)',
                      cursor: 'pointer',
                      padding: '2px 4px',
                      fontSize: '14px'
                    }
                  }, '‚Üì') : null,

                  // Delete
                  project.structure.length > 1 ? e('button', {
                    onClick: () => deleteChapter(chapter.id),
                    title: 'Poista luku',
                    style: {
                      background: 'transparent',
                      border: 'none',
                      color: 'var(--text-3)',
                      cursor: 'pointer',
                      padding: '2px 4px',
                      fontSize: '14px'
                    }
                  }, '√ó') : null
                ) : null
              )
            )
          ),

          // Add chapter button
          e('button', {
            onClick: addChapter,
            style: {
              width: '100%',
              padding: '8px',
              background: 'transparent',
              border: '1px solid var(--border-color)',
              borderRadius: '4px',
              color: 'var(--text-2)',
              cursor: 'pointer',
              fontFamily: 'IBM Plex Mono',
              fontSize: '12px',
              transition: 'all 0.2s'
            }
          }, '+ Uusi luku')
        )
      ),

      // Center editor
      e('div', { className: 'faust-editor' },
        e('div', { className: 'faust-editor-content' },
          // Chapter title
          e('input', {
            value: activeChapter.title,
            onChange: (ev) => {
              setProject(prev => ({
                ...prev,
                structure: prev.structure.map(ch =>
                  ch.id === activeChapterId ? { ...ch, title: ev.target.value } : ch
                )
              }));
              setUnsavedChanges(true);
            },
            placeholder: 'Luvun otsikko',
            style: {
              width: '100%',
              background: 'transparent',
              border: 'none',
              outline: 'none',
              color: 'var(--ink)',
              fontFamily: 'EB Garamond',
              fontSize: '32px',
              fontWeight: 600,
              marginBottom: '8px',
              borderBottom: '2px solid transparent'
            }
          }),

          // Word count and AI quality bar
          e('div', {
            style: {
              display: 'flex',
              alignItems: 'center',
              gap: '16px',
              marginBottom: '8px'
            }
          },
            // Word count
            e('div', {
              style: {
                fontFamily: 'IBM Plex Mono',
                fontSize: '13px',
                color: 'var(--text-3)'
              }
            }, `${activeChapter.wordCount} sanaa`),

            // AI Quality score
            activeChapter.aiQuality && activeChapter.aiQuality.score > 0 ? e('div', {
              style: {
                fontFamily: 'IBM Plex Mono',
                fontSize: '12px',
                color: activeChapter.aiQuality.score >= 8 ? '#4CAF50' :
                       activeChapter.aiQuality.score >= 6 ? '#FFA726' : '#EF5350',
                padding: '2px 8px',
                borderRadius: '4px',
                background: 'var(--bg-2)',
                border: '1px solid currentColor'
              }
            }, `AI: ${activeChapter.aiQuality.score.toFixed(1)}/10`) : null,

            // Status badge
            e('div', {
              style: {
                fontFamily: 'IBM Plex Mono',
                fontSize: '11px',
                color: 'var(--text-3)',
                padding: '2px 8px',
                borderRadius: '4px',
                background: 'var(--bg-2)',
                textTransform: 'uppercase'
              }
            }, activeChapter.status || 'draft'),

            // Pacing indicator
            activeChapter.pacing && activeChapter.pacing.speed ? e('div', {
              style: {
                fontFamily: 'IBM Plex Mono',
                fontSize: '11px',
                color: 'var(--text-3)'
              }
            }, `Tempo: ${activeChapter.pacing.speed}`) : null
          ),

          // AI Actions bar
          e('div', {
            style: {
              display: 'flex',
              gap: '8px',
              marginBottom: '16px',
              paddingBottom: '16px',
              borderBottom: '1px solid var(--border-color)'
            }
          },
            // Analyze button
            e('button', {
              onClick: () => analyzeChapterContent(activeChapterId),
              style: {
                padding: '4px 12px',
                background: 'transparent',
                border: '1px solid var(--border-color)',
                borderRadius: '4px',
                color: 'var(--text-2)',
                cursor: 'pointer',
                fontFamily: 'IBM Plex Mono',
                fontSize: '11px'
              }
            }, 'ü§ñ Analysoi'),

            // Quick quality check
            e('button', {
              onClick: () => quickQualityCheck(activeChapterId),
              style: {
                padding: '4px 12px',
                background: 'transparent',
                border: '1px solid var(--border-color)',
                borderRadius: '4px',
                color: 'var(--text-2)',
                cursor: 'pointer',
                fontFamily: 'IBM Plex Mono',
                fontSize: '11px'
              }
            }, '‚ö° Pika-arvio'),

            // Generate synopsis
            e('button', {
              onClick: () => generateSynopsis(activeChapterId),
              style: {
                padding: '4px 12px',
                background: 'transparent',
                border: '1px solid var(--border-color)',
                borderRadius: '4px',
                color: 'var(--text-2)',
                cursor: 'pointer',
                fontFamily: 'IBM Plex Mono',
                fontSize: '11px'
              }
            }, 'üìù Synopsis'),

            // Generate chapter
            e('button', {
              onClick: () => generateChapter(activeChapterId),
              disabled: isGenerating,
              style: {
                padding: '4px 12px',
                background: isGenerating ? 'var(--bg-2)' : 'var(--sigil)',
                border: '1px solid var(--sigil)',
                borderRadius: '4px',
                color: isGenerating ? 'var(--text-3)' : '#000',
                cursor: isGenerating ? 'not-allowed' : 'pointer',
                fontFamily: 'IBM Plex Mono',
                fontSize: '11px',
                fontWeight: 600,
                opacity: isGenerating ? 0.5 : 1
              }
            }, isGenerating ? '‚è≥ Generoidaan...' : '‚ú® Generoi AI:lla')
          ),

          // Generation progress indicator
          generationProgress && e('div', {
            style: {
              padding: '8px 16px',
              background: 'var(--sigil)' + '22',
              border: '1px solid var(--sigil)',
              borderRadius: '4px',
              fontFamily: 'IBM Plex Mono',
              fontSize: '12px',
              color: 'var(--sigil)',
              marginTop: '8px'
            }
          }, generationProgress.message),

          // AI Suggestions (if any)
          activeChapter.aiQuality && activeChapter.aiQuality.suggestions && activeChapter.aiQuality.suggestions.length > 0 ? e('div', {
            style: {
              marginBottom: '16px',
              padding: '12px',
              background: 'rgba(255,193,7,0.1)',
              border: '1px solid rgba(255,193,7,0.3)',
              borderRadius: '4px'
            }
          },
            e('div', {
              style: {
                fontFamily: 'IBM Plex Mono',
                fontSize: '11px',
                color: '#FFA726',
                marginBottom: '8px',
                fontWeight: 600
              }
            }, 'üí° AI:n ehdotukset:'),
            ...activeChapter.aiQuality.suggestions.map((suggestion, idx) =>
              e('div', {
                key: idx,
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '12px',
                  color: 'var(--text)',
                  marginBottom: '4px'
                }
              }, `‚Ä¢ ${suggestion}`)
            )
          ) : null,

          // Textarea
          e('textarea', {
            ref: editorRef,
            className: 'faust-textarea',
            value: activeChapter.content,
            onChange: (ev) => updateChapterContent(ev.target.value),
            onMouseUp: handleTextSelection,
            onKeyUp: handleTextSelection,
            placeholder: 'Aloita kirjoittaminen...',
            style: {
              fontFamily: 'EB Garamond',
              fontSize: '18px',
              lineHeight: '1.8'
            }
          }),

          // Voice edit button (appears when text is selected)
          voiceInputAvailable && textSelection && !voiceDiffView ? e('div', {
            style: {
              position: 'absolute',
              bottom: '16px',
              left: '50%',
              transform: 'translateX(-50%)',
              background: 'var(--bg-1)',
              border: '1px solid var(--border-color)',
              borderRadius: '8px',
              padding: '12px 20px',
              boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
              display: 'flex',
              alignItems: 'center',
              gap: '12px',
              zIndex: 100
            }
          },
            e('button', {
              onClick: handleVoiceEdit,
              disabled: voiceState !== 'idle',
              style: {
                background: voiceState === 'listening' ? '#ff4444' :
                           voiceState === 'processing' ? '#ffaa00' : 'var(--bronze)',
                border: 'none',
                borderRadius: '50%',
                width: '48px',
                height: '48px',
                fontSize: '24px',
                cursor: voiceState === 'idle' ? 'pointer' : 'not-allowed',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                animation: voiceState === 'listening' ? 'pulse 1s infinite' : 'none'
              }
            },
              voiceState === 'listening' ? 'üî¥' :
              voiceState === 'processing' ? '‚è∏Ô∏è' : 'üé§'
            ),
            e('div', {
              style: {
                fontFamily: 'IBM Plex Mono',
                fontSize: '12px',
                color: 'var(--text-2)'
              }
            },
              voiceState === 'listening' ? 'Kuuntelen...' :
              voiceState === 'processing' ? 'K√§sittelen...' :
              'Kerro miten haluat muuttaa teksti√§'
            )
          ) : null,

          // Voice diff view (when AI has generated new version)
          voiceDiffView ? e('div', {
            style: {
              position: 'absolute',
              top: '50%',
              left: '50%',
              transform: 'translate(-50%, -50%)',
              background: 'var(--bg-1)',
              border: '2px solid var(--bronze)',
              borderRadius: '8px',
              padding: '24px',
              boxShadow: '0 8px 24px rgba(0,0,0,0.4)',
              maxWidth: '80%',
              maxHeight: '80%',
              overflow: 'auto',
              zIndex: 200
            }
          },
            e('h3', {
              style: {
                fontFamily: 'EB Garamond',
                fontSize: '18px',
                color: 'var(--text)',
                marginBottom: '16px'
              }
            }, `Ohje: "${voiceDiffView.instruction}"`),

            // Original text
            e('div', {
              style: {
                marginBottom: '16px',
                padding: '12px',
                background: 'var(--bg-2)',
                borderRadius: '4px',
                border: '1px solid var(--border-color)'
              }
            },
              e('div', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '11px',
                  color: 'var(--text-3)',
                  marginBottom: '8px'
                }
              }, 'ALKUPER√ÑINEN:'),
              e('div', {
                style: {
                  fontFamily: 'EB Garamond',
                  fontSize: '16px',
                  color: 'var(--text-2)',
                  lineHeight: '1.6'
                }
              }, voiceDiffView.original)
            ),

            // Revised text
            e('div', {
              style: {
                marginBottom: '24px',
                padding: '12px',
                background: 'var(--bg-2)',
                borderRadius: '4px',
                border: '1px solid var(--bronze)'
              }
            },
              e('div', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '11px',
                  color: 'var(--text-3)',
                  marginBottom: '8px'
                }
              }, 'UUSI VERSIO:'),
              e('div', {
                style: {
                  fontFamily: 'EB Garamond',
                  fontSize: '16px',
                  color: 'var(--text)',
                  lineHeight: '1.6'
                }
              }, voiceDiffView.revised)
            ),

            // Actions
            e('div', {
              style: {
                display: 'flex',
                gap: '12px',
                justifyContent: 'flex-end'
              }
            },
              e('button', {
                onClick: rejectVoiceEdit,
                style: {
                  padding: '8px 16px',
                  background: 'transparent',
                  border: '1px solid var(--border-color)',
                  borderRadius: '4px',
                  color: 'var(--text-2)',
                  cursor: 'pointer',
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '12px'
                }
              }, 'Hylk√§√§'),
              e('button', {
                onClick: acceptVoiceEdit,
                style: {
                  padding: '8px 16px',
                  background: 'var(--bronze)',
                  border: 'none',
                  borderRadius: '4px',
                  color: '#000',
                  cursor: 'pointer',
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '12px',
                  fontWeight: 600
                }
              }, 'Hyv√§ksy')
            )
          ) : null
        )
      ),

      // Right inspector (hidden by default)
      e('div', { className: showInspector ? 'faust-inspector visible' : 'faust-inspector' },
        e('div', { style: { padding: '16px', color: 'var(--text)' } },
          e('h3', { style: { fontFamily: 'EB Garamond', fontSize: '16px', marginBottom: '12px' } }, 'Inspector'),

          // Project metadata
          e('div', { style: { marginBottom: '16px', paddingBottom: '16px', borderBottom: '1px solid var(--border-color)' } },
            e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '11px', color: 'var(--text-3)', marginBottom: '8px' } }, 'PROJEKTI'),
            e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '13px', color: 'var(--text-2)', marginBottom: '4px' } },
              `Genre: ${project.genre}`),
            e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '13px', color: 'var(--text-2)', marginBottom: '4px' } },
              `Tavoite: ${project.targets.totalWords} sanaa`),
            e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '13px', color: 'var(--text-2)' } },
              `Edistyminen: ${Math.round(project.targets.currentTotal / project.targets.totalWords * 100)}%`)
          ),

          // AI Writing Mode
          e('div', { style: { marginBottom: '16px', paddingBottom: '16px', borderBottom: '1px solid var(--border-color)' } },
            e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '11px', color: 'var(--text-3)', marginBottom: '8px' } }, 'AI WRITING MODE'),

            // Mode selector buttons
            e('div', { style: { display: 'flex', gap: '4px', marginBottom: '12px' } },
              Object.keys(project.ai.modes).map(modeName =>
                e('button', {
                  key: modeName,
                  onClick: () => setAIMode(modeName),
                  style: {
                    flex: 1,
                    padding: '6px',
                    background: project.ai.currentMode === modeName ? project.ai.modes[modeName].color : 'transparent',
                    border: `1px solid ${project.ai.modes[modeName].color}`,
                    borderRadius: '4px',
                    color: project.ai.currentMode === modeName ? '#000' : 'var(--text-2)',
                    cursor: 'pointer',
                    fontFamily: 'IBM Plex Mono',
                    fontSize: '10px',
                    fontWeight: project.ai.currentMode === modeName ? 600 : 400,
                    transition: 'all 0.2s'
                  }
                }, project.ai.modes[modeName].name)
              )
            ),

            // Current mode info
            e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '11px', color: 'var(--text-2)', marginBottom: '4px' } },
              `L√§mp√∂tila: ${getCurrentMode().temperature}`),
            e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '11px', color: 'var(--text-3)', fontStyle: 'italic' } },
              getCurrentMode().useCase)
          ),

          // AI Provider
          e('div', { style: { marginBottom: '16px', paddingBottom: '16px', borderBottom: '1px solid var(--border-color)' } },
            e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '11px', color: 'var(--text-3)', marginBottom: '8px' } }, 'AI PROVIDER'),

            // Provider selector buttons with API key input
            e('div', { style: { display: 'flex', flexDirection: 'column', gap: '4px', marginBottom: '8px' } },
              ['anthropic', 'openai', 'deepseek', 'grok'].map(providerName => {
                const labels = {
                  anthropic: 'Claude (Anthropic)',
                  openai: 'GPT-4 (OpenAI)',
                  deepseek: 'DeepSeek',
                  grok: 'Grok (xAI)'
                };
                const isActive = (project.ai.provider || 'anthropic') === providerName;
                const showInput = showApiKeyInput === providerName;

                const hasKey = apiKeysStatus[providerName];

                return e('div', { key: providerName, style: { display: 'flex', flexDirection: 'column', gap: '4px' } },
                  // Provider button (click to select AND open API input)
                  e('button', {
                    onClick: () => {
                      setAIProvider(providerName);
                      toggleApiKeyInput(providerName);
                    },
                    style: {
                      width: '100%',
                      padding: '8px 12px',
                      background: isActive ? 'var(--sigil)' : 'transparent',
                      border: `1px solid ${isActive ? 'var(--sigil)' : 'var(--border-color)'}`,
                      borderRadius: '4px',
                      color: isActive ? '#000' : 'var(--text-2)',
                      cursor: 'pointer',
                      fontFamily: 'IBM Plex Mono',
                      fontSize: '11px',
                      fontWeight: isActive ? 600 : 400,
                      textAlign: 'left',
                      transition: 'all 0.2s',
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center'
                    }
                  },
                    e('span', null, labels[providerName]),
                    e('span', { style: { fontSize: '14px' } },
                      hasKey ? '‚úÖ' : '‚ùå'
                    )
                  ),

                  // API key input (shown when clicked)
                  showInput && e('div', { style: { display: 'flex', flexDirection: 'column', gap: '4px', padding: '8px', background: 'var(--bg-2)', borderRadius: '4px', border: '1px solid var(--border-color)' } },
                    e('input', {
                      type: 'password',
                      placeholder: 'API-avain...',
                      value: apiKeyInputValue,
                      onChange: (ev) => setApiKeyInputValue(ev.target.value),
                      style: {
                        padding: '6px 8px',
                        background: 'var(--bg)',
                        border: '1px solid var(--border-color)',
                        borderRadius: '4px',
                        color: 'var(--text)',
                        fontFamily: 'IBM Plex Mono',
                        fontSize: '11px'
                      }
                    }),
                    e('div', { style: { display: 'flex', gap: '4px' } },
                      e('button', {
                        onClick: () => saveApiKey(providerName, apiKeyInputValue),
                        disabled: !apiKeyInputValue.trim(),
                        style: {
                          flex: 1,
                          padding: '4px 8px',
                          background: apiKeyInputValue.trim() ? 'var(--sigil)' : 'var(--bg-2)',
                          border: '1px solid var(--sigil)',
                          borderRadius: '4px',
                          color: apiKeyInputValue.trim() ? '#000' : 'var(--text-3)',
                          cursor: apiKeyInputValue.trim() ? 'pointer' : 'not-allowed',
                          fontFamily: 'IBM Plex Mono',
                          fontSize: '10px',
                          fontWeight: 600
                        }
                      }, 'Tallenna'),
                      e('button', {
                        onClick: () => toggleApiKeyInput(providerName),
                        style: {
                          padding: '4px 8px',
                          background: 'transparent',
                          border: '1px solid var(--border-color)',
                          borderRadius: '4px',
                          color: 'var(--text-2)',
                          cursor: 'pointer',
                          fontFamily: 'IBM Plex Mono',
                          fontSize: '10px'
                        }
                      }, 'Peruuta')
                    )
                  )
                );
              })
            ),

            // Current provider info
            e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '10px', color: 'var(--text-3)', fontStyle: 'italic' } },
              'Oletusprovider kaikille toiminnoille'),

            // Advanced: Per-function providers
            e('details', { style: { marginTop: '12px' } },
              e('summary', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '10px',
                  color: 'var(--sigil)',
                  cursor: 'pointer',
                  userSelect: 'none',
                  marginBottom: '8px'
                }
              }, '‚ñ∏ Toimintokohtaiset providerit'),

              e('div', { style: { marginTop: '8px', padding: '8px', background: 'var(--bg-2)', borderRadius: '4px', border: '1px solid var(--border-color)' } },
                // Generation provider
                e('div', { style: { marginBottom: '8px' } },
                  e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '10px', color: 'var(--text-3)', marginBottom: '4px' } }, 'Luku-generointi:'),
                  e('select', {
                    value: project.ai.providers?.generation || 'anthropic',
                    onChange: (ev) => {
                      setProject(prev => ({
                        ...prev,
                        ai: {
                          ...prev.ai,
                          providers: {
                            ...prev.ai.providers,
                            generation: ev.target.value
                          }
                        }
                      }));
                      setUnsavedChanges(true);
                    },
                    style: {
                      width: '100%',
                      padding: '4px 8px',
                      background: 'var(--bg)',
                      border: '1px solid var(--border-color)',
                      borderRadius: '4px',
                      color: 'var(--text)',
                      fontFamily: 'IBM Plex Mono',
                      fontSize: '11px'
                    }
                  },
                    e('option', { value: 'anthropic' }, 'Claude (Anthropic)'),
                    e('option', { value: 'openai' }, 'GPT-4 (OpenAI)'),
                    e('option', { value: 'deepseek' }, 'DeepSeek'),
                    e('option', { value: 'grok' }, 'Grok (xAI)')
                  )
                ),

                // Continuity provider
                e('div', { style: { marginBottom: '8px' } },
                  e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '10px', color: 'var(--text-3)', marginBottom: '4px' } }, 'Jatkuvuustarkistus:'),
                  e('select', {
                    value: project.ai.providers?.continuity || 'anthropic',
                    onChange: (ev) => {
                      setProject(prev => ({
                        ...prev,
                        ai: {
                          ...prev.ai,
                          providers: {
                            ...prev.ai.providers,
                            continuity: ev.target.value
                          }
                        }
                      }));
                      setUnsavedChanges(true);
                    },
                    style: {
                      width: '100%',
                      padding: '4px 8px',
                      background: 'var(--bg)',
                      border: '1px solid var(--border-color)',
                      borderRadius: '4px',
                      color: 'var(--text)',
                      fontFamily: 'IBM Plex Mono',
                      fontSize: '11px'
                    }
                  },
                    e('option', { value: 'anthropic' }, 'Claude (Anthropic)'),
                    e('option', { value: 'openai' }, 'GPT-4 (OpenAI)'),
                    e('option', { value: 'deepseek' }, 'DeepSeek'),
                    e('option', { value: 'grok' }, 'Grok (xAI)')
                  )
                ),

                // Analysis provider
                e('div', { style: { marginBottom: '0' } },
                  e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '10px', color: 'var(--text-3)', marginBottom: '4px' } }, 'Laatuanalyysi:'),
                  e('select', {
                    value: project.ai.providers?.analysis || 'anthropic',
                    onChange: (ev) => {
                      setProject(prev => ({
                        ...prev,
                        ai: {
                          ...prev.ai,
                          providers: {
                            ...prev.ai.providers,
                            analysis: ev.target.value
                          }
                        }
                      }));
                      setUnsavedChanges(true);
                    },
                    style: {
                      width: '100%',
                      padding: '4px 8px',
                      background: 'var(--bg)',
                      border: '1px solid var(--border-color)',
                      borderRadius: '4px',
                      color: 'var(--text)',
                      fontFamily: 'IBM Plex Mono',
                      fontSize: '11px'
                    }
                  },
                    e('option', { value: 'anthropic' }, 'Claude (Anthropic)'),
                    e('option', { value: 'openai' }, 'GPT-4 (OpenAI)'),
                    e('option', { value: 'deepseek' }, 'DeepSeek'),
                    e('option', { value: 'grok' }, 'Grok (xAI)')
                  )
                ),

                e('div', { style: { marginTop: '8px', fontFamily: 'IBM Plex Mono', fontSize: '9px', color: 'var(--text-3)', fontStyle: 'italic' } },
                  'üí° Voit k√§ytt√§√§ eri malleja eri toiminnoille (esim. DeepSeek generointi, Claude jatkuvuus)')
              )
            )
          ),

          // Story Complexity
          complexity && e('div', { style: { marginBottom: '16px', paddingBottom: '16px', borderBottom: '1px solid var(--border-color)' } },
            e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '11px', color: 'var(--text-3)', marginBottom: '8px' } }, 'TARINAN KOMPLEKSISUUS'),

            // Complexity score badge
            e('div', {
              style: {
                display: 'inline-block',
                padding: '4px 8px',
                background: complexity.recommendation.color + '22',
                border: `1px solid ${complexity.recommendation.color}`,
                borderRadius: '4px',
                marginBottom: '8px'
              }
            },
              e('span', { style: { fontFamily: 'IBM Plex Mono', fontSize: '14px', fontWeight: 600, color: complexity.recommendation.color } },
                `${complexity.score} / 100`)
            ),

            // Phase indicator
            e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '12px', color: 'var(--text)', marginBottom: '4px', fontWeight: 500 } },
              complexity.recommendation.title),

            // Breakdown
            e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '11px', color: 'var(--text-3)', marginBottom: '8px' } },
              e('div', null, `üìñ ${complexity.wordCount.toLocaleString('fi-FI')} sanaa`),
              e('div', null, `üë• ${complexity.characterCount} hahmoa`),
              e('div', null, `üìç ${complexity.plotThreadCount} juonilankaa`),
              e('div', null, `‚è∞ ${complexity.timelineCount} aikajanaa`),
              complexity.hasNonLinear && e('div', null, `üîÄ Ep√§lineaarinen`)
            ),

            // Recommendation
            e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '10px', color: 'var(--text-3)', marginTop: '8px', padding: '8px', background: 'var(--bg-2)', borderRadius: '4px', borderLeft: `3px solid ${complexity.recommendation.color}` } },
              e('div', { style: { fontWeight: 500, marginBottom: '4px' } }, complexity.recommendation.message),
              e('div', { style: { fontStyle: 'italic' } }, complexity.recommendation.action),
              e('div', { style: { marginTop: '4px', color: complexity.recommendation.color } }, `Tarkkuus: ${complexity.recommendation.accuracy}`)
            )
          ),

          // Characters
          e('div', { style: { marginBottom: '16px', paddingBottom: '16px', borderBottom: '1px solid var(--border-color)' } },
            e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '11px', color: 'var(--text-3)', marginBottom: '8px' } }, 'HAHMOT'),

            project.castPlan.defined
              ? e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '13px', color: 'var(--text-2)', marginBottom: '8px' } },
                  `${project.characters.length} / ${project.castPlan.totalCharacters} hahmoa`)
              : e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '13px', color: 'var(--text-3)', marginBottom: '8px', fontStyle: 'italic' } },
                  'Ei suunniteltua cast:ia'),

            // Plan Cast button (or Build Characters if cast is defined)
            !project.castPlan.defined
              ? e('button', {
                  onClick: () => setShowCastPlanDialog(true),
                  style: {
                    width: '100%',
                    padding: '8px',
                    marginTop: '8px',
                    background: 'var(--bronze)',
                    border: 'none',
                    borderRadius: '4px',
                    color: '#000',
                    cursor: 'pointer',
                    fontFamily: 'IBM Plex Mono',
                    fontSize: '12px',
                    fontWeight: 600
                  }
                }, 'üé≠ Plan Cast')
              : e('div', { style: { marginTop: '8px' } },
                  // List of character types from cast plan
                  e('div', { style: { marginBottom: '8px' } },
                    project.castPlan.characterTypes.map((type, idx) =>
                      e('div', {
                        key: idx,
                        style: {
                          fontFamily: 'IBM Plex Mono',
                          fontSize: '11px',
                          color: 'var(--text-3)',
                          marginBottom: '4px'
                        }
                      }, `${idx + 1}. ${type.length > 30 ? type.substring(0, 30) + '...' : type}`)
                    )
                  ),

                  // Build detailed characters button
                  e('button', {
                    onClick: () => {
                      setShowCharacterBuilder(true);
                      setCharacterBuilderStep(1);
                    },
                    style: {
                      width: '100%',
                      padding: '8px',
                      background: 'var(--bronze)',
                      border: 'none',
                      borderRadius: '4px',
                      color: '#000',
                      cursor: 'pointer',
                      fontFamily: 'IBM Plex Mono',
                      fontSize: '12px',
                      fontWeight: 600
                    }
                  }, 'üë§ Build Characters')
                )
          ),

          // AI Chat
          e('div', { style: { marginBottom: '16px', paddingBottom: '16px', borderBottom: '1px solid var(--border-color)' } },
            e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '11px', color: 'var(--text-3)', marginBottom: '8px' } }, 'AI CHAT'),

            // Chat history
            e('div', {
              style: {
                maxHeight: '300px',
                overflowY: 'auto',
                marginBottom: '12px',
                padding: '8px',
                background: 'var(--bg-1)',
                borderRadius: '4px',
                border: '1px solid var(--border-color)'
              }
            },
              aiChatHistory.length === 0
                ? e('div', {
                    style: {
                      fontFamily: 'IBM Plex Mono',
                      fontSize: '11px',
                      color: 'var(--text-3)',
                      fontStyle: 'italic',
                      textAlign: 'center',
                      padding: '12px'
                    }
                  }, 'Kysy AI:lta mit√§ tahansa...')
                : aiChatHistory.map((msg, idx) =>
                    e('div', {
                      key: idx,
                      style: {
                        marginBottom: '12px',
                        padding: '8px',
                        background: msg.role === 'user' ? 'var(--bg-2)' :
                                   msg.role === 'error' ? 'rgba(255,68,68,0.1)' : 'transparent',
                        borderLeft: msg.role === 'user' ? '2px solid var(--bronze)' :
                                   msg.role === 'error' ? '2px solid #ff4444' : '2px solid var(--sigil)',
                        borderRadius: '4px'
                      }
                    },
                      e('div', {
                        style: {
                          fontFamily: 'IBM Plex Mono',
                          fontSize: '10px',
                          color: 'var(--text-3)',
                          marginBottom: '4px',
                          textTransform: 'uppercase'
                        }
                      }, msg.role === 'user' ? 'Sin√§' : msg.role === 'error' ? 'Virhe' : 'FAUST AI'),
                      e('div', {
                        style: {
                          fontFamily: 'IBM Plex Mono',
                          fontSize: '12px',
                          color: 'var(--text)',
                          lineHeight: '1.5',
                          whiteSpace: 'pre-wrap'
                        }
                      }, msg.content)
                    )
                  )
            ),

            // Input area
            e('div', {
              style: {
                display: 'flex',
                gap: '8px',
                marginBottom: '8px'
              }
            },
              e('input', {
                type: 'text',
                value: aiChatInput,
                onChange: (ev) => setAiChatInput(ev.target.value),
                onKeyPress: (ev) => {
                  if (ev.key === 'Enter') {
                    sendAiChatMessage(aiChatInput);
                  }
                },
                placeholder: 'Kirjoita tai puhu...',
                disabled: aiChatVoiceState === 'processing',
                style: {
                  flex: 1,
                  padding: '8px',
                  background: 'var(--bg-1)',
                  border: '1px solid var(--border-color)',
                  borderRadius: '4px',
                  color: 'var(--text)',
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '12px',
                  outline: 'none'
                }
              }),

              // Voice button
              voiceInputAvailable ? e('button', {
                onClick: handleAiChatVoice,
                disabled: aiChatVoiceState !== 'idle',
                style: {
                  padding: '8px 12px',
                  background: aiChatVoiceState === 'listening' ? '#ff4444' :
                             aiChatVoiceState === 'processing' ? '#ffaa00' : 'var(--bronze)',
                  border: 'none',
                  borderRadius: '4px',
                  color: '#000',
                  cursor: aiChatVoiceState === 'idle' ? 'pointer' : 'not-allowed',
                  fontSize: '16px',
                  animation: aiChatVoiceState === 'listening' ? 'pulse 1s infinite' : 'none'
                }
              },
                aiChatVoiceState === 'listening' ? 'üî¥' :
                aiChatVoiceState === 'processing' ? '‚è∏Ô∏è' : 'üé§'
              ) : null
            ),

            // Send button
            e('button', {
              onClick: () => sendAiChatMessage(aiChatInput),
              disabled: !aiChatInput.trim() || aiChatVoiceState === 'processing',
              style: {
                width: '100%',
                padding: '8px',
                background: aiChatInput.trim() && aiChatVoiceState !== 'processing' ? 'var(--bronze)' : 'transparent',
                border: '1px solid var(--border-color)',
                borderRadius: '4px',
                color: aiChatInput.trim() && aiChatVoiceState !== 'processing' ? '#000' : 'var(--text-3)',
                cursor: aiChatInput.trim() && aiChatVoiceState !== 'processing' ? 'pointer' : 'not-allowed',
                fontFamily: 'IBM Plex Mono',
                fontSize: '12px',
                fontWeight: 600
              }
            },
              aiChatVoiceState === 'processing' ? 'K√§sittelen...' : 'L√§het√§'
            )
          ),

          // AI Tools (placeholder)
          e('div', null,
            e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '11px', color: 'var(--text-3)', marginBottom: '8px' } }, 'AI-TY√ñKALUT'),
            e('button', {
              disabled: true,
              style: {
                width: '100%',
                padding: '8px',
                marginBottom: '8px',
                background: 'transparent',
                border: '1px solid var(--border-color)',
                color: 'var(--text-3)',
                borderRadius: '4px',
                cursor: 'not-allowed',
                fontFamily: 'IBM Plex Mono',
                fontSize: '12px'
              }
            }, 'Jatka kirjoitusta'),
            e('button', {
              disabled: true,
              style: {
                width: '100%',
                padding: '8px',
                marginBottom: '8px',
                background: 'transparent',
                border: '1px solid var(--border-color)',
                color: 'var(--text-3)',
                borderRadius: '4px',
                cursor: 'not-allowed',
                fontFamily: 'IBM Plex Mono',
                fontSize: '12px'
              }
            }, 'Generoi kirja')
          )
        )
      )
    ),

    // Footer / Status bar
    e('div', { className: 'faust-footer' },
      e('div', {
        style: {
          padding: '4px 16px',
          color: 'var(--text-2)',
          fontSize: '12px',
          fontFamily: 'IBM Plex Mono',
          display: 'flex',
          justifyContent: 'space-between'
        }
      },
        e('span', null, activeChapter.title + (unsavedChanges ? ' ‚Ä¢' : '')),
        e('span', null, `${activeChapter.wordCount} / ${project.targets.currentTotal} sanaa` +
          (currentFilePath ? ` ‚Ä¢ ${currentFilePath.split('/').pop()}` : ' ‚Ä¢ Tallentamaton'))
      )
    ),

    // Cast Planning Dialog
    showCastPlanDialog ? e('div', {
      style: {
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        background: 'rgba(0,0,0,0.8)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000
      },
      onClick: (ev) => {
        if (ev.target === ev.currentTarget) {
          setShowCastPlanDialog(false);
          setCastPlanStep(1);
        }
      }
    },
      e('div', {
        style: {
          background: 'var(--bg-primary)',
          border: '1px solid var(--border-color)',
          borderRadius: '8px',
          width: '600px',
          maxHeight: '80vh',
          overflow: 'auto',
          padding: '24px'
        }
      },
        // Dialog header
        e('h2', {
          style: {
            fontFamily: 'EB Garamond',
            fontSize: '24px',
            color: 'var(--text)',
            marginBottom: '16px'
          }
        }, 'üé≠ Plan Cast'),

        e('p', {
          style: {
            fontFamily: 'IBM Plex Mono',
            fontSize: '13px',
            color: 'var(--text-2)',
            marginBottom: '24px'
          }
        }, 'M√§√§rittele millaisia hahmotyyppej√§ kirjassasi on. AI ehdottaa arkkityyppej√§ ja analysoi hahmodynamiikkaa.'),

        // Step 1: Character types input
        castPlanStep === 1 ? e('div', null,
          e('label', {
            style: {
              fontFamily: 'IBM Plex Mono',
              fontSize: '12px',
              color: 'var(--text-3)',
              display: 'block',
              marginBottom: '8px'
            }
          }, 'HAHMOTYYPIT (yksi per rivi):'),

          e('textarea', {
            placeholder: 'Esim:\nStoalainen vanhus - viisas mutta et√§inen\nNuori idealisti - naiivi mutta intohimoinen\nKorruptoitunut poliitikko - vieh√§tt√§v√§ mutta ontto',
            style: {
              width: '100%',
              minHeight: '200px',
              background: 'var(--bg-secondary)',
              border: '1px solid var(--border-color)',
              borderRadius: '4px',
              color: 'var(--text)',
              padding: '12px',
              fontFamily: 'IBM Plex Mono',
              fontSize: '13px',
              lineHeight: '1.6',
              resize: 'vertical'
            },
            id: 'cast-types-input'
          }),

          // Actions
          e('div', { style: { marginTop: '24px', display: 'flex', gap: '12px', justifyContent: 'flex-end' } },
            e('button', {
              onClick: () => {
                setShowCastPlanDialog(false);
                setCastPlanStep(1);
              },
              style: {
                padding: '8px 16px',
                background: 'transparent',
                border: '1px solid var(--border-color)',
                borderRadius: '4px',
                color: 'var(--text-2)',
                cursor: 'pointer',
                fontFamily: 'IBM Plex Mono',
                fontSize: '12px'
              }
            }, 'Peruuta'),

            e('button', {
              onClick: async () => {
                const input = document.getElementById('cast-types-input').value;
                const types = input.split('\n').filter(line => line.trim().length > 0);

                if (types.length === 0) {
                  alert('Sy√∂t√§ v√§hint√§√§n yksi hahmotyyppi');
                  return;
                }

                // Save types to project
                setProject(prev => ({
                  ...prev,
                  castPlan: {
                    ...prev.castPlan,
                    characterTypes: types,
                    totalCharacters: types.length
                  }
                }));

                // Move to step 2 and start AI analysis
                setCastPlanStep(2);

                // Run AI analysis
                const analysis = await analyzeCast(types);

                if (analysis) {
                  // Save analysis results
                  setProject(prev => ({
                    ...prev,
                    castPlan: {
                      ...prev.castPlan,
                      suggestedArchetypes: analysis.suggestions || [],
                      castDynamics: analysis.dynamics || null,
                      warnings: analysis.warnings || []
                    }
                  }));

                  setCastPlanStep(3); // Move to review step
                } else {
                  alert('AI-analyysi ep√§onnistui. Tarkista API-avain.');
                  setCastPlanStep(1); // Back to input
                }
              },
              style: {
                padding: '8px 16px',
                background: 'var(--bronze)',
                border: 'none',
                borderRadius: '4px',
                color: '#000',
                cursor: 'pointer',
                fontFamily: 'IBM Plex Mono',
                fontSize: '12px',
                fontWeight: 600
              }
            }, 'Analysoi AI:lla ‚Üí')
          )
        ) : null,

        // Step 2: AI Analysis loading
        castPlanStep === 2 ? e('div', null,
          e('div', {
            style: {
              fontFamily: 'IBM Plex Mono',
              fontSize: '13px',
              color: 'var(--text-2)',
              textAlign: 'center',
              padding: '40px'
            }
          },
            e('div', { style: { fontSize: '32px', marginBottom: '16px' } }, 'ü§ñ'),
            e('div', null, 'AI analysoi hahmotyyppej√§...'),
            e('div', { style: { fontSize: '11px', color: 'var(--text-3)', marginTop: '8px' } }, 'T√§m√§ voi kest√§√§ 10-30 sekuntia')
          )
        ) : null,

        // Step 3: AI Analysis Results
        castPlanStep === 3 ? e('div', null,
          e('div', { style: { marginBottom: '16px' } },
            e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '11px', color: 'var(--text-3)', marginBottom: '8px' } }, 'AI-EHDOTUKSET'),

            // Archetype suggestions
            project.castPlan.suggestedArchetypes.map((suggestion, idx) =>
              e('div', {
                key: idx,
                style: {
                  marginBottom: '16px',
                  padding: '12px',
                  background: 'var(--bg-secondary)',
                  border: '1px solid var(--border-color)',
                  borderRadius: '4px'
                }
              },
                e('div', { style: { fontFamily: 'EB Garamond', fontSize: '16px', color: 'var(--text)', marginBottom: '4px', fontWeight: 600 } },
                  suggestion.type),
                e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '11px', color: 'var(--bronze)', marginBottom: '8px' } },
                  suggestion.archetypeFamily),

                e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '12px', color: 'var(--text-2)', marginBottom: '4px' } },
                  `Esimerkit: ${suggestion.examples.join(', ')}`),
                e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '12px', color: 'var(--text-2)', marginBottom: '4px' } },
                  `Rooli: ${suggestion.functionInStory}`),
                e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '12px', color: 'var(--text-3)' } },
                  `Haasteet: ${suggestion.flaws}`)
              )
            )
          ),

          // Warnings
          project.castPlan.warnings && project.castPlan.warnings.length > 0 ? e('div', { style: { marginBottom: '16px' } },
            e('div', { style: { fontFamily: 'IBM Plex Mono', fontSize: '11px', color: 'var(--text-3)', marginBottom: '8px' } }, '‚ö†Ô∏è HUOMIOT'),
            project.castPlan.warnings.map((warning, idx) =>
              e('div', {
                key: idx,
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '12px',
                  color: 'var(--text-2)',
                  marginBottom: '4px'
                }
              }, `‚Ä¢ ${warning}`)
            )
          ) : null,

          // Actions
          e('div', { style: { marginTop: '24px', display: 'flex', gap: '12px', justifyContent: 'flex-end' } },
            e('button', {
              onClick: () => setCastPlanStep(1),
              style: {
                padding: '8px 16px',
                background: 'transparent',
                border: '1px solid var(--border-color)',
                borderRadius: '4px',
                color: 'var(--text-2)',
                cursor: 'pointer',
                fontFamily: 'IBM Plex Mono',
                fontSize: '12px'
              }
            }, '‚Üê Muokkaa'),

            e('button', {
              onClick: () => {
                // Mark cast plan as defined
                setProject(prev => ({
                  ...prev,
                  castPlan: {
                    ...prev.castPlan,
                    defined: true
                  }
                }));
                setUnsavedChanges(true);
                setShowCastPlanDialog(false);
                setCastPlanStep(1);
              },
              style: {
                padding: '8px 16px',
                background: 'var(--bronze)',
                border: 'none',
                borderRadius: '4px',
                color: '#000',
                cursor: 'pointer',
                fontFamily: 'IBM Plex Mono',
                fontSize: '12px',
                fontWeight: 600
              }
            }, 'Vahvista cast ‚Üí')
          )
        ) : null
      )
    ) : null,

    // Character Builder Dialog
    showCharacterBuilder ? e('div', {
      style: {
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        background: 'rgba(0, 0, 0, 0.85)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 9999
      }
    },
      e('div', {
        style: {
          background: 'var(--bg-1)',
          border: '2px solid var(--bronze)',
          borderRadius: '8px',
          padding: '32px',
          maxWidth: '800px',
          width: '90%',
          maxHeight: '90vh',
          overflow: 'auto',
          position: 'relative'
        }
      },
        // Header
        e('h2', {
          style: {
            fontFamily: 'EB Garamond',
            fontSize: '24px',
            color: 'var(--text)',
            marginBottom: '8px'
          }
        }, 'üë§ Character Archetype Builder'),

        e('p', {
          style: {
            fontFamily: 'IBM Plex Mono',
            fontSize: '12px',
            color: 'var(--text-2)',
            marginBottom: '24px'
          }
        }, selectedCharacterType ? `Tyyppi: ${selectedCharacterType.type}` : 'Valitse hahmotyyppi'),

        // Cancel button (top right)
        e('button', {
          onClick: cancelCharacterBuilder,
          style: {
            position: 'absolute',
            top: '24px',
            right: '24px',
            background: 'transparent',
            border: '1px solid var(--border-color)',
            borderRadius: '4px',
            color: 'var(--text-3)',
            padding: '4px 12px',
            cursor: 'pointer',
            fontFamily: 'IBM Plex Mono',
            fontSize: '12px'
          }
        }, 'Peru'),

        // Step 1: Select character type
        characterBuilderStep === 1 ? e('div', null,
          e('div', {
            style: {
              fontFamily: 'IBM Plex Mono',
              fontSize: '13px',
              color: 'var(--text-2)',
              marginBottom: '16px'
            }
          }, 'Valitse haluamasi hahmotyyppi cast-suunnitelmasta:'),

          e('div', {
            style: {
              display: 'flex',
              flexDirection: 'column',
              gap: '8px'
            }
          },
            project.castPlan.characterTypes.map((type, idx) =>
              e('button', {
                key: idx,
                onClick: () => startCharacterBuilder(type),
                style: {
                  padding: '12px',
                  background: 'var(--bg-2)',
                  border: '1px solid var(--border-color)',
                  borderRadius: '4px',
                  color: 'var(--text)',
                  cursor: 'pointer',
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '13px',
                  textAlign: 'left',
                  transition: 'all 0.2s'
                }
              }, `${idx + 1}. ${type}`)
            )
          )
        ) : null,

        // Step 2: Input real people
        characterBuilderStep === 2 ? e('div', null,
          e('div', {
            style: {
              fontFamily: 'IBM Plex Mono',
              fontSize: '13px',
              color: 'var(--text-2)',
              marginBottom: '16px'
            }
          }, 'Anna oikeita henkil√∂it√§ inspiraatioksi:'),

          e('div', {
            style: {
              marginBottom: '16px',
              padding: '12px',
              background: 'var(--bg-2)',
              borderRadius: '4px',
              border: '1px solid var(--sigil)'
            }
          },
            e('div', {
              style: {
                fontFamily: 'IBM Plex Mono',
                fontSize: '11px',
                color: 'var(--text-3)',
                marginBottom: '8px'
              }
            }, 'ARKKITYYPPI:'),
            e('div', {
              style: {
                fontFamily: 'EB Garamond',
                fontSize: '14px',
                color: 'var(--sigil)',
                marginBottom: '4px'
              }
            }, selectedCharacterType.archetype.archetypeFamily),
            e('div', {
              style: {
                fontFamily: 'IBM Plex Mono',
                fontSize: '11px',
                color: 'var(--text-3)'
              }
            }, `Esimerkit: ${selectedCharacterType.archetype.examples.join(', ')}`)
          ),

          e('textarea', {
            value: characterRealPeople,
            onChange: (ev) => setCharacterRealPeople(ev.target.value),
            placeholder: 'Esim:\nErnst J√ºnger + C.G. Jung\n\nYhdistele 1-3 henkil√∂√§ per rivi. Voit lis√§t√§ useita rivill√§.',
            style: {
              width: '100%',
              minHeight: '120px',
              padding: '12px',
              background: 'var(--bg-2)',
              border: '1px solid var(--border-color)',
              borderRadius: '4px',
              color: 'var(--text)',
              fontFamily: 'IBM Plex Mono',
              fontSize: '13px',
              resize: 'vertical',
              marginBottom: '16px'
            }
          }),

          e('button', {
            onClick: handleCharacterPeopleSubmit,
            disabled: !characterRealPeople.trim(),
            style: {
              width: '100%',
              padding: '12px',
              background: characterRealPeople.trim() ? 'var(--bronze)' : 'transparent',
              border: '1px solid var(--border-color)',
              borderRadius: '4px',
              color: characterRealPeople.trim() ? '#000' : 'var(--text-3)',
              cursor: characterRealPeople.trim() ? 'pointer' : 'not-allowed',
              fontFamily: 'IBM Plex Mono',
              fontSize: '13px',
              fontWeight: 600
            }
          }, 'Jatka kysymyksiin ‚Üí')
        ) : null,

        // Step 3: AI generating questions (loading)
        characterBuilderStep === 3 ? e('div', {
          style: {
            textAlign: 'center',
            padding: '48px'
          }
        },
          e('div', { style: { fontSize: '48px', marginBottom: '16px' } }, 'ü§ñ'),
          e('div', {
            style: {
              fontFamily: 'IBM Plex Mono',
              fontSize: '14px',
              color: 'var(--text)',
              marginBottom: '8px'
            }
          }, 'AI generoi tarkentavia kysymyksi√§...'),
          e('div', {
            style: {
              fontFamily: 'IBM Plex Mono',
              fontSize: '12px',
              color: 'var(--text-3)'
            }
          }, 'T√§m√§ voi kest√§√§ 10-20 sekuntia')
        ) : null,

        // Step 4: Answer questions
        characterBuilderStep === 4 ? e('div', null,
          e('div', {
            style: {
              fontFamily: 'IBM Plex Mono',
              fontSize: '13px',
              color: 'var(--text-2)',
              marginBottom: '16px'
            }
          }, `Vastaa AI:n kysymyksiin (${characterQuestions.length} kpl):`),

          e('div', {
            style: {
              display: 'flex',
              flexDirection: 'column',
              gap: '16px',
              marginBottom: '24px'
            }
          },
            characterQuestions.map((q, idx) =>
              e('div', {
                key: q.id,
                style: {
                  padding: '16px',
                  background: 'var(--bg-2)',
                  border: '1px solid var(--border-color)',
                  borderRadius: '4px'
                }
              },
                e('div', {
                  style: {
                    fontFamily: 'IBM Plex Mono',
                    fontSize: '11px',
                    color: 'var(--text-3)',
                    marginBottom: '8px',
                    textTransform: 'uppercase'
                  }
                }, `${idx + 1}. ${q.category}`),
                e('div', {
                  style: {
                    fontFamily: 'EB Garamond',
                    fontSize: '15px',
                    color: 'var(--text)',
                    marginBottom: '12px'
                  }
                }, q.question),
                e('textarea', {
                  value: characterAnswers[q.id] || '',
                  onChange: (ev) => {
                    setCharacterAnswers(prev => ({
                      ...prev,
                      [q.id]: ev.target.value
                    }));
                  },
                  placeholder: 'Vastauksesi...',
                  style: {
                    width: '100%',
                    minHeight: '80px',
                    padding: '12px',
                    background: 'var(--bg-1)',
                    border: '1px solid var(--border-color)',
                    borderRadius: '4px',
                    color: 'var(--text)',
                    fontFamily: 'IBM Plex Mono',
                    fontSize: '12px',
                    resize: 'vertical'
                  }
                })
              )
            )
          ),

          e('button', {
            onClick: handleCharacterAnswersSubmit,
            style: {
              width: '100%',
              padding: '12px',
              background: 'var(--bronze)',
              border: 'none',
              borderRadius: '4px',
              color: '#000',
              cursor: 'pointer',
              fontFamily: 'IBM Plex Mono',
              fontSize: '13px',
              fontWeight: 600
            }
          }, 'Generoi hahmon profiili ‚Üí')
        ) : null,

        // Step 5: AI generating profile (loading)
        characterBuilderStep === 5 ? e('div', {
          style: {
            textAlign: 'center',
            padding: '48px'
          }
        },
          e('div', { style: { fontSize: '48px', marginBottom: '16px' } }, '‚ú®'),
          e('div', {
            style: {
              fontFamily: 'IBM Plex Mono',
              fontSize: '14px',
              color: 'var(--text)',
              marginBottom: '8px'
            }
          }, 'AI luo yksityiskohtaisen psykologisen profiilin...'),
          e('div', {
            style: {
              fontFamily: 'IBM Plex Mono',
              fontSize: '12px',
              color: 'var(--text-3)'
            }
          }, 'T√§m√§ voi kest√§√§ 20-40 sekuntia')
        ) : null,

        // Step 6: Review profile
        characterBuilderStep === 6 && characterProfile ? e('div', null,
          e('div', {
            style: {
              fontFamily: 'IBM Plex Mono',
              fontSize: '13px',
              color: 'var(--text-2)',
              marginBottom: '24px'
            }
          }, 'Tarkista hahmon profiili:'),

          // Scrollable profile content
          e('div', {
            style: {
              maxHeight: '60vh',
              overflowY: 'auto',
              marginBottom: '24px',
              padding: '16px',
              background: 'var(--bg-2)',
              borderRadius: '4px',
              border: '1px solid var(--sigil)'
            }
          },
            // Basic info
            e('div', { style: { marginBottom: '24px' } },
              e('h3', {
                style: {
                  fontFamily: 'EB Garamond',
                  fontSize: '20px',
                  color: 'var(--sigil)',
                  marginBottom: '12px'
                }
              }, characterProfile.name),
              e('div', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '12px',
                  color: 'var(--text-2)',
                  marginBottom: '4px'
                }
              }, `Ik√§: ${characterProfile.age}`),
              e('div', {
                style: {
                  fontFamily: 'EB Garamond',
                  fontSize: '14px',
                  color: 'var(--text)',
                  fontStyle: 'italic'
                }
              }, characterProfile.appearance)
            ),

            // Psychology
            e('div', { style: { marginBottom: '24px' } },
              e('div', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '11px',
                  color: 'var(--text-3)',
                  marginBottom: '8px',
                  textTransform: 'uppercase'
                }
              }, 'Psykologia'),
              e('div', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '12px',
                  color: 'var(--text-2)',
                  marginBottom: '4px'
                }
              }, `MBTI: ${characterProfile.psychology.mbti} | Enneagram: ${characterProfile.psychology.enneagram}`),
              e('div', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '12px',
                  color: 'var(--text)'
                }
              }, characterProfile.psychology.traits.join(', '))
            ),

            // Shadow
            e('div', { style: { marginBottom: '24px' } },
              e('div', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '11px',
                  color: 'var(--text-3)',
                  marginBottom: '8px',
                  textTransform: 'uppercase'
                }
              }, 'Shadow (Jung)'),
              e('div', {
                style: {
                  fontFamily: 'EB Garamond',
                  fontSize: '13px',
                  color: 'var(--text)',
                  marginBottom: '8px'
                }
              }, `Piilotettu: ${characterProfile.shadow.hidden}`),
              e('div', {
                style: {
                  fontFamily: 'EB Garamond',
                  fontSize: '13px',
                  color: 'var(--text)',
                  marginBottom: '8px'
                }
              }, `Pelko: ${characterProfile.shadow.fear}`),
              e('div', {
                style: {
                  fontFamily: 'EB Garamond',
                  fontSize: '13px',
                  color: 'var(--text)'
                }
              }, `Halu: ${characterProfile.shadow.desire}`)
            ),

            // Voice samples
            e('div', { style: { marginBottom: '24px' } },
              e('div', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '11px',
                  color: 'var(--text-3)',
                  marginBottom: '8px',
                  textTransform: 'uppercase'
                }
              }, 'Puhetyyli'),
              e('div', {
                style: {
                  fontFamily: 'EB Garamond',
                  fontSize: '13px',
                  color: 'var(--text-2)',
                  marginBottom: '12px',
                  fontStyle: 'italic'
                }
              }, characterProfile.voice.style),
              ...characterProfile.voice.examples.map((example, idx) =>
                e('div', {
                  key: idx,
                  style: {
                    fontFamily: 'EB Garamond',
                    fontSize: '14px',
                    color: 'var(--text)',
                    marginBottom: '8px',
                    paddingLeft: '12px',
                    borderLeft: '2px solid var(--bronze)'
                  }
                }, `"${example}"`)
              )
            ),

            // Transformation arc
            e('div', { style: { marginBottom: '24px' } },
              e('div', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '11px',
                  color: 'var(--text-3)',
                  marginBottom: '8px',
                  textTransform: 'uppercase'
                }
              }, 'Muutoskaari'),
              e('div', {
                style: {
                  fontFamily: 'EB Garamond',
                  fontSize: '13px',
                  color: 'var(--text)',
                  marginBottom: '8px'
                }
              }, `Alku: ${characterProfile.arc.beginning}`),
              e('div', {
                style: {
                  fontFamily: 'EB Garamond',
                  fontSize: '13px',
                  color: 'var(--bronze)',
                  marginBottom: '8px'
                }
              }, `Katalyytti: ${characterProfile.arc.catalyst}`),
              e('div', {
                style: {
                  fontFamily: 'EB Garamond',
                  fontSize: '13px',
                  color: 'var(--text)'
                }
              }, `Loppu: ${characterProfile.arc.end}`)
            ),

            // Key scenes
            characterProfile.keyScenes && characterProfile.keyScenes.length > 0 ? e('div', null,
              e('div', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '11px',
                  color: 'var(--text-3)',
                  marginBottom: '8px',
                  textTransform: 'uppercase'
                }
              }, 'Avainkohtaukset'),
              ...characterProfile.keyScenes.map((scene, idx) =>
                e('div', {
                  key: idx,
                  style: {
                    marginBottom: '12px',
                    padding: '12px',
                    background: 'var(--bg-1)',
                    borderRadius: '4px'
                  }
                },
                  e('div', {
                    style: {
                      fontFamily: 'IBM Plex Mono',
                      fontSize: '12px',
                      color: 'var(--sigil)',
                      marginBottom: '4px',
                      fontWeight: 600
                    }
                  }, scene.title),
                  e('div', {
                    style: {
                      fontFamily: 'EB Garamond',
                      fontSize: '13px',
                      color: 'var(--text-2)'
                    }
                  }, scene.description)
                )
              )
            ) : null
          ),

          // Action buttons
          e('div', {
            style: {
              display: 'flex',
              gap: '12px'
            }
          },
            e('button', {
              onClick: () => {
                setCharacterBuilderStep(4);
                setCharacterProfile(null);
              },
              style: {
                flex: 1,
                padding: '12px',
                background: 'transparent',
                border: '1px solid var(--border-color)',
                borderRadius: '4px',
                color: 'var(--text-2)',
                cursor: 'pointer',
                fontFamily: 'IBM Plex Mono',
                fontSize: '12px'
              }
            }, '‚Üê Takaisin kysymyksiin'),
            e('button', {
              onClick: saveCharacterProfile,
              style: {
                flex: 2,
                padding: '12px',
                background: 'var(--bronze)',
                border: 'none',
                borderRadius: '4px',
                color: '#000',
                cursor: 'pointer',
                fontFamily: 'IBM Plex Mono',
                fontSize: '13px',
                fontWeight: 600
              }
            }, '‚úì Tallenna hahmo')
          )
        ) : null
      )
    ) : null,

    // Settings Dialog
    showSettings ? e('div', {
      style: {
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        background: 'rgba(0, 0, 0, 0.85)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 10000
      }
    },
      e('div', {
        style: {
          background: 'var(--bg-1)',
          border: '2px solid var(--bronze)',
          borderRadius: '8px',
          padding: '32px',
          maxWidth: '700px',
          width: '90%',
          maxHeight: '90vh',
          overflow: 'auto',
          position: 'relative'
        }
      },
        // Header
        e('h2', {
          style: {
            fontFamily: 'EB Garamond',
            fontSize: '24px',
            color: 'var(--text)',
            marginBottom: '8px'
          }
        }, '‚öôÔ∏è Asetukset'),

        e('p', {
          style: {
            fontFamily: 'IBM Plex Mono',
            fontSize: '12px',
            color: 'var(--text-2)',
            marginBottom: '24px'
          }
        }, 'Konfiguroi FAUST AI -asetukset'),

        // Close button
        e('button', {
          onClick: () => setShowSettings(false),
          style: {
            position: 'absolute',
            top: '24px',
            right: '24px',
            background: 'transparent',
            border: '1px solid var(--border-color)',
            borderRadius: '4px',
            color: 'var(--text-3)',
            padding: '4px 12px',
            cursor: 'pointer',
            fontFamily: 'IBM Plex Mono',
            fontSize: '12px'
          }
        }, 'Sulje'),

        // Tabs
        e('div', {
          style: {
            display: 'flex',
            gap: '8px',
            marginBottom: '24px',
            borderBottom: '1px solid var(--border-color)',
            paddingBottom: '12px'
          }
        },
          ['api', 'general'].map(tab =>
            e('button', {
              key: tab,
              onClick: () => setSettingsTab(tab),
              style: {
                padding: '8px 16px',
                background: settingsTab === tab ? 'var(--bronze)' : 'transparent',
                border: '1px solid var(--border-color)',
                borderRadius: '4px',
                color: settingsTab === tab ? '#000' : 'var(--text-2)',
                cursor: 'pointer',
                fontFamily: 'IBM Plex Mono',
                fontSize: '12px',
                fontWeight: settingsTab === tab ? 600 : 400
              }
            }, tab === 'api' ? 'API Asetukset' : 'Yleiset')
          )
        ),

        // API Settings Tab
        settingsTab === 'api' ? e('div', null,
          // Provider selection
          e('div', {
            style: {
              marginBottom: '24px'
            }
          },
            e('div', {
              style: {
                fontFamily: 'IBM Plex Mono',
                fontSize: '12px',
                color: 'var(--text-3)',
                marginBottom: '8px',
                textTransform: 'uppercase'
              }
            }, 'AI Provider'),

            e('div', {
              style: {
                display: 'flex',
                gap: '8px'
              }
            },
              ['anthropic', 'openai', 'local'].map(provider =>
                e('button', {
                  key: provider,
                  onClick: () => setActiveApiProvider(provider),
                  style: {
                    flex: 1,
                    padding: '12px',
                    background: project.apiConfig.provider === provider ? 'var(--bg-2)' : 'transparent',
                    border: `2px solid ${project.apiConfig.provider === provider ? 'var(--bronze)' : 'var(--border-color)'}`,
                    borderRadius: '4px',
                    color: 'var(--text)',
                    cursor: 'pointer',
                    fontFamily: 'IBM Plex Mono',
                    fontSize: '13px'
                  }
                },
                  provider === 'anthropic' ? 'Anthropic Claude' :
                  provider === 'openai' ? 'OpenAI GPT' : 'Local Model'
                )
              )
            )
          ),

          // API Key input (for selected provider)
          project.apiConfig.provider !== 'local' ? e('div', {
            style: {
              marginBottom: '24px'
            }
          },
            e('div', {
              style: {
                fontFamily: 'IBM Plex Mono',
                fontSize: '12px',
                color: 'var(--text-3)',
                marginBottom: '8px',
                textTransform: 'uppercase'
              }
            }, `${project.apiConfig.provider === 'anthropic' ? 'Anthropic' : 'OpenAI'} API Key`),

            e('input', {
              type: 'password',
              value: project.apiConfig[project.apiConfig.provider].apiKey,
              onChange: (ev) => updateApiKey(project.apiConfig.provider, ev.target.value),
              placeholder: project.apiConfig.provider === 'anthropic' ?
                'sk-ant-...' : 'sk-...',
              style: {
                width: '100%',
                padding: '12px',
                background: 'var(--bg-2)',
                border: '1px solid var(--border-color)',
                borderRadius: '4px',
                color: 'var(--text)',
                fontFamily: 'IBM Plex Mono',
                fontSize: '13px',
                outline: 'none'
              }
            }),

            e('div', {
              style: {
                fontFamily: 'IBM Plex Mono',
                fontSize: '11px',
                color: 'var(--text-3)',
                marginTop: '8px',
                fontStyle: 'italic'
              }
            },
              project.apiConfig.provider === 'anthropic' ?
                'Hanki avain: console.anthropic.com' :
                'Hanki avain: platform.openai.com'
            )
          ) : null,

          // Local endpoint (for local provider)
          project.apiConfig.provider === 'local' ? e('div', {
            style: {
              marginBottom: '24px'
            }
          },
            e('div', {
              style: {
                fontFamily: 'IBM Plex Mono',
                fontSize: '12px',
                color: 'var(--text-3)',
                marginBottom: '8px',
                textTransform: 'uppercase'
              }
            }, 'Local Endpoint'),

            e('input', {
              type: 'text',
              value: project.apiConfig.local.endpoint,
              onChange: (ev) => {
                setProject(prev => ({
                  ...prev,
                  apiConfig: {
                    ...prev.apiConfig,
                    local: {
                      ...prev.apiConfig.local,
                      endpoint: ev.target.value
                    }
                  }
                }));
                setUnsavedChanges(true);
              },
              placeholder: 'http://localhost:1234',
              style: {
                width: '100%',
                padding: '12px',
                background: 'var(--bg-2)',
                border: '1px solid var(--border-color)',
                borderRadius: '4px',
                color: 'var(--text)',
                fontFamily: 'IBM Plex Mono',
                fontSize: '13px',
                outline: 'none'
              }
            })
          ) : null,

          // Model names section
          e('div', {
            style: {
              marginBottom: '24px',
              marginTop: '32px',
              paddingTop: '24px',
              borderTop: '1px solid var(--border-color)'
            }
          },
            e('div', {
              style: {
                fontFamily: 'IBM Plex Mono',
                fontSize: '12px',
                color: 'var(--text-3)',
                marginBottom: '16px',
                textTransform: 'uppercase'
              }
            }, 'Mallinnimet (Model Names)'),

            // Anthropic Claude model
            e('div', { style: { marginBottom: '12px' } },
              e('label', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '11px',
                  color: 'var(--text-2)',
                  marginBottom: '4px',
                  display: 'block'
                }
              }, 'Anthropic Claude:'),
              e('input', {
                type: 'text',
                value: project.ai?.models?.anthropic || 'claude-3-5-sonnet-20241022',
                onChange: (ev) => {
                  setProject(prev => ({
                    ...prev,
                    ai: {
                      ...prev.ai,
                      models: {
                        ...prev.ai.models,
                        anthropic: ev.target.value
                      }
                    }
                  }));
                  setUnsavedChanges(true);
                },
                placeholder: 'claude-3-5-sonnet-20241022',
                style: {
                  width: '100%',
                  padding: '8px',
                  background: 'var(--bg-2)',
                  border: '1px solid var(--border-color)',
                  borderRadius: '4px',
                  color: 'var(--text)',
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '12px',
                  outline: 'none'
                }
              })
            ),

            // OpenAI GPT model
            e('div', { style: { marginBottom: '12px' } },
              e('label', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '11px',
                  color: 'var(--text-2)',
                  marginBottom: '4px',
                  display: 'block'
                }
              }, 'OpenAI GPT:'),
              e('input', {
                type: 'text',
                value: project.ai?.models?.openai || 'gpt-4-turbo-preview',
                onChange: (ev) => {
                  setProject(prev => ({
                    ...prev,
                    ai: {
                      ...prev.ai,
                      models: {
                        ...prev.ai.models,
                        openai: ev.target.value
                      }
                    }
                  }));
                  setUnsavedChanges(true);
                },
                placeholder: 'gpt-4-turbo-preview',
                style: {
                  width: '100%',
                  padding: '8px',
                  background: 'var(--bg-2)',
                  border: '1px solid var(--border-color)',
                  borderRadius: '4px',
                  color: 'var(--text)',
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '12px',
                  outline: 'none'
                }
              })
            ),

            // Grok xAI model
            e('div', { style: { marginBottom: '12px' } },
              e('label', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '11px',
                  color: 'var(--text-2)',
                  marginBottom: '4px',
                  display: 'block'
                }
              }, 'Grok (xAI):'),
              e('input', {
                type: 'text',
                value: project.ai?.models?.grok || 'grok-2-1212',
                onChange: (ev) => {
                  setProject(prev => ({
                    ...prev,
                    ai: {
                      ...prev.ai,
                      models: {
                        ...prev.ai.models,
                        grok: ev.target.value
                      }
                    }
                  }));
                  setUnsavedChanges(true);
                },
                placeholder: 'grok-2-1212',
                style: {
                  width: '100%',
                  padding: '8px',
                  background: 'var(--bg-2)',
                  border: '1px solid var(--border-color)',
                  borderRadius: '4px',
                  color: 'var(--text)',
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '12px',
                  outline: 'none'
                }
              })
            ),

            // DeepSeek model
            e('div', { style: { marginBottom: '12px' } },
              e('label', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '11px',
                  color: 'var(--text-2)',
                  marginBottom: '4px',
                  display: 'block'
                }
              }, 'DeepSeek:'),
              e('input', {
                type: 'text',
                value: project.ai?.models?.deepseek || 'deepseek-chat',
                onChange: (ev) => {
                  setProject(prev => ({
                    ...prev,
                    ai: {
                      ...prev.ai,
                      models: {
                        ...prev.ai.models,
                        deepseek: ev.target.value
                      }
                    }
                  }));
                  setUnsavedChanges(true);
                },
                placeholder: 'deepseek-chat',
                style: {
                  width: '100%',
                  padding: '8px',
                  background: 'var(--bg-2)',
                  border: '1px solid var(--border-color)',
                  borderRadius: '4px',
                  color: 'var(--text)',
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '12px',
                  outline: 'none'
                }
              })
            ),

            e('div', { style: { marginTop: '8px', fontFamily: 'IBM Plex Mono', fontSize: '9px', color: 'var(--text-3)', fontStyle: 'italic' } },
              'üí° Voit k√§ytt√§√§ mit√§ tahansa mallia joka toimii providerisi API:lla (esim. gpt-4o, claude-opus-4-20250514, grok-3)')
          ),

          // Test connection button
          e('button', {
            onClick: testApiConnection,
            style: {
              width: '100%',
              padding: '12px',
              background: 'var(--bronze)',
              border: 'none',
              borderRadius: '4px',
              color: '#000',
              cursor: 'pointer',
              fontFamily: 'IBM Plex Mono',
              fontSize: '13px',
              fontWeight: 600,
              marginBottom: '16px'
            }
          }, 'üîç Testaa yhteytt√§'),

          // Test result
          apiTestResult ? e('div', {
            style: {
              padding: '12px',
              background: apiTestResult.success === null ? 'var(--bg-2)' :
                         apiTestResult.success ? 'rgba(76,175,80,0.1)' : 'rgba(239,83,80,0.1)',
              border: `1px solid ${apiTestResult.success === null ? 'var(--border-color)' :
                                   apiTestResult.success ? '#4CAF50' : '#EF5350'}`,
              borderRadius: '4px',
              marginBottom: '16px'
            }
          },
            e('div', {
              style: {
                fontFamily: 'IBM Plex Mono',
                fontSize: '12px',
                color: apiTestResult.success === null ? 'var(--text-2)' :
                       apiTestResult.success ? '#4CAF50' : '#EF5350'
              }
            }, apiTestResult.message)
          ) : null,

          // API Usage stats
          e('div', {
            style: {
              padding: '16px',
              background: 'var(--bg-2)',
              borderRadius: '4px',
              border: '1px solid var(--border-color)'
            }
          },
            e('div', {
              style: {
                fontFamily: 'IBM Plex Mono',
                fontSize: '11px',
                color: 'var(--text-3)',
                marginBottom: '12px',
                textTransform: 'uppercase'
              }
            }, 'API K√§ytt√∂'),

            e('div', {
              style: {
                display: 'flex',
                flexDirection: 'column',
                gap: '8px'
              }
            },
              e('div', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '12px',
                  color: 'var(--text-2)'
                }
              }, `Pyynt√∂j√§: ${project.ai.costTracking.requestCount}`),
              e('div', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '12px',
                  color: 'var(--text-2)'
                }
              }, `Tokeneita: ${project.ai.costTracking.tokensUsed}`),
              e('div', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '12px',
                  color: 'var(--text-2)'
                }
              }, `Kustannukset: ~$${project.ai.costTracking.totalSpent.toFixed(2)}`),
              project.apiConfig.lastTested ? e('div', {
                style: {
                  fontFamily: 'IBM Plex Mono',
                  fontSize: '11px',
                  color: 'var(--text-3)',
                  fontStyle: 'italic',
                  marginTop: '4px'
                }
              }, `Viimeksi testattu: ${new Date(project.apiConfig.lastTested).toLocaleString('fi-FI')}`) : null
            )
          )
        ) : null,

        // General Settings Tab
        settingsTab === 'general' ? e('div', null,
          e('div', {
            style: {
              fontFamily: 'IBM Plex Mono',
              fontSize: '13px',
              color: 'var(--text-2)',
              textAlign: 'center',
              padding: '48px'
            }
          }, 'Yleisi√§ asetuksia tulossa...')
        ) : null
      )
    ) : null,

    // DEBUG: Simple test element
    aiAssistantOpen && e('div', {
      style: {
        position: 'fixed',
        right: '10px',
        top: '100px',
        width: '200px',
        height: '100px',
        background: 'red',
        color: 'white',
        zIndex: 99999,
        padding: '20px',
        fontFamily: 'monospace',
        fontSize: '16px'
      }
    }, 'LIMINAL ACTIVE!'),

    // AI Assistant Panel (Cursor-style) - Slides in from right
    aiAssistantOpen && e('div', {
      className: 'liminal-engine-panel',
      style: {
        position: 'fixed',
        right: 0,
        top: 0,
        bottom: 0,
        width: '500px',
        background: 'var(--bg-primary)',
        borderLeft: '2px solid var(--bronze)',
        boxShadow: '-4px 0 20px rgba(0,0,0,0.3)',
        display: 'flex',
        flexDirection: 'column',
        zIndex: 9999,
        animation: 'slideInFromRight 0.3s ease-out'
      }
    },
      // Header
      e('div', {
        style: {
          padding: '16px',
          borderBottom: '1px solid var(--border-color)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'space-between'
        }
      },
        e('div', {
          style: {
            fontFamily: 'IBM Plex Mono',
            fontSize: '14px',
            fontWeight: 600,
            color: 'var(--text)'
          }
        }, 'Liminal Engine'),
        e('button', {
          onClick: () => setAiAssistantOpen(false),
          style: {
            background: 'transparent',
            border: 'none',
            color: 'var(--text-2)',
            cursor: 'pointer',
            padding: '4px 8px',
            fontFamily: 'IBM Plex Mono',
            fontSize: '18px'
          }
        }, '√ó')
      ),

      // Model selector dropdown
      e('div', {
        style: {
          padding: '12px 16px',
          borderBottom: '1px solid var(--border-color)',
          background: 'var(--bg-secondary)'
        }
      },
        e('div', {
          style: {
            fontFamily: 'IBM Plex Mono',
            fontSize: '10px',
            color: 'var(--text-3)',
            marginBottom: '6px',
            textTransform: 'uppercase'
          }
        }, 'Provider'),
        e('select', {
          value: project.ai.provider || 'anthropic',
          onChange: (ev) => {
            setProject(prev => ({
              ...prev,
              ai: {
                ...prev.ai,
                provider: ev.target.value
              }
            }));
            setUnsavedChanges(true);
          },
          style: {
            width: '100%',
            padding: '8px',
            background: 'var(--bg-primary)',
            border: '1px solid var(--border-color)',
            borderRadius: '4px',
            color: 'var(--text)',
            fontFamily: 'IBM Plex Mono',
            fontSize: '12px',
            cursor: 'pointer',
            outline: 'none',
            marginBottom: '8px'
          }
        },
          e('option', { value: 'anthropic' }, 'Anthropic Claude'),
          e('option', { value: 'openai' }, 'OpenAI GPT'),
          e('option', { value: 'grok' }, 'Grok (xAI)'),
          e('option', { value: 'deepseek' }, 'DeepSeek')
        ),
        e('div', {
          style: {
            fontFamily: 'IBM Plex Mono',
            fontSize: '10px',
            color: 'var(--text-3)',
            marginBottom: '6px',
            textTransform: 'uppercase',
            marginTop: '4px'
          }
        }, 'Model'),
        e('input', {
          type: 'text',
          value: project.ai.models?.[project.ai.provider || 'anthropic'] ||
                 (project.ai.provider === 'anthropic' ? 'claude-3-5-sonnet-20241022' :
                  project.ai.provider === 'openai' ? 'gpt-4-turbo-preview' :
                  project.ai.provider === 'grok' ? 'grok-2-1212' : 'deepseek-chat'),
          onChange: (ev) => {
            const provider = project.ai.provider || 'anthropic';
            setProject(prev => ({
              ...prev,
              ai: {
                ...prev.ai,
                models: {
                  ...prev.ai.models,
                  [provider]: ev.target.value
                }
              }
            }));
            setUnsavedChanges(true);
          },
          placeholder: 'e.g. claude-opus-4-20250514',
          style: {
            width: '100%',
            padding: '8px',
            background: 'var(--bg-primary)',
            border: '1px solid var(--border-color)',
            borderRadius: '4px',
            color: 'var(--gold)',
            fontFamily: 'IBM Plex Mono',
            fontSize: '11px',
            outline: 'none'
          }
        })
      ),

      // Selected text context badge
      textSelection ? e('div', {
        style: {
          padding: '12px 16px',
          background: 'var(--bronze)',
          color: '#000',
          fontFamily: 'IBM Plex Mono',
          fontSize: '11px',
          borderBottom: '1px solid var(--border-color)'
        }
      },
        e('div', { style: { fontWeight: 600, marginBottom: '4px' } }, '‚úì Text Selected'),
        e('div', { style: { opacity: 0.8, maxHeight: '40px', overflow: 'hidden' } },
          textSelection.text.substring(0, 80) + (textSelection.text.length > 80 ? '...' : ''))
      ) : null,

      // Chat messages
      e('div', {
        style: {
          flex: 1,
          overflowY: 'auto',
          padding: '16px',
          display: 'flex',
          flexDirection: 'column',
          gap: '12px'
        }
      },
        aiChatMessages.length === 0
          ? e('div', {
              style: {
                fontFamily: 'IBM Plex Mono',
                fontSize: '12px',
                color: 'var(--text-3)',
                textAlign: 'center',
                padding: '48px 24px',
                fontStyle: 'italic'
              }
            }, 'Select text and ask me to revise it, or ask me anything about your writing.')
          : aiChatMessages.map((msg, idx) =>
              e('div', {
                key: idx,
                style: {
                  padding: '12px',
                  background: msg.role === 'user' ? 'var(--bg-secondary)' :
                             msg.role === 'error' ? 'rgba(255,68,68,0.1)' : 'transparent',
                  borderLeft: msg.role === 'user' ? '3px solid var(--bronze)' :
                             msg.role === 'error' ? '3px solid #ff4444' : '3px solid var(--gold)',
                  borderRadius: '4px'
                }
              },
                e('div', {
                  style: {
                    fontFamily: 'IBM Plex Mono',
                    fontSize: '9px',
                    color: 'var(--text-3)',
                    marginBottom: '6px',
                    textTransform: 'uppercase',
                    fontWeight: 600
                  }
                }, msg.role === 'user' ? 'You' : msg.role === 'error' ? 'Error' : 'AI'),
                msg.selectedText ? e('div', {
                  style: {
                    fontFamily: 'IBM Plex Mono',
                    fontSize: '10px',
                    color: 'var(--text-3)',
                    fontStyle: 'italic',
                    marginBottom: '8px',
                    padding: '6px',
                    background: 'var(--bg-primary)',
                    borderRadius: '2px',
                    maxHeight: '60px',
                    overflow: 'hidden'
                  }
                }, 'üìù ' + msg.selectedText.substring(0, 100) + (msg.selectedText.length > 100 ? '...' : '')) : null,
                e('div', {
                  style: {
                    fontFamily: 'IBM Plex Mono',
                    fontSize: '12px',
                    color: 'var(--text)',
                    lineHeight: '1.6',
                    whiteSpace: 'pre-wrap'
                  }
                }, msg.content)
              )
            )
      ),

      // AI Suggestion diff preview
      aiSuggestion && !aiSuggestion.applied ? e('div', {
        style: {
          padding: '16px',
          borderTop: '2px solid var(--gold)',
          background: 'var(--bg-secondary)'
        }
      },
        e('div', {
          style: {
            fontFamily: 'IBM Plex Mono',
            fontSize: '11px',
            color: 'var(--text-3)',
            marginBottom: '8px',
            textTransform: 'uppercase',
            fontWeight: 600
          }
        }, 'Suggestion'),
        e('div', {
          style: {
            marginBottom: '12px',
            maxHeight: '150px',
            overflowY: 'auto',
            padding: '12px',
            background: 'var(--bg-primary)',
            borderRadius: '4px',
            fontFamily: 'EB Garamond',
            fontSize: '14px',
            lineHeight: '1.6',
            color: 'var(--text)'
          }
        }, aiSuggestion.revised),
        e('div', {
          style: {
            display: 'flex',
            gap: '8px'
          }
        },
          e('button', {
            onClick: applyAiSuggestion,
            style: {
              flex: 1,
              padding: '10px',
              background: 'var(--gold)',
              border: 'none',
              borderRadius: '4px',
              color: '#000',
              cursor: 'pointer',
              fontFamily: 'IBM Plex Mono',
              fontSize: '12px',
              fontWeight: 600
            }
          }, 'Apply'),
          e('button', {
            onClick: () => setAiSuggestion(null),
            style: {
              flex: 1,
              padding: '10px',
              background: 'transparent',
              border: '1px solid var(--border-color)',
              borderRadius: '4px',
              color: 'var(--text)',
              cursor: 'pointer',
              fontFamily: 'IBM Plex Mono',
              fontSize: '12px'
            }
          }, 'Dismiss')
        )
      ) : null,

      // Input area
      e('div', {
        style: {
          padding: '16px',
          borderTop: '1px solid var(--border-color)',
          background: 'var(--bg-secondary)'
        }
      },
        e('div', {
          style: {
            display: 'flex',
            gap: '8px'
          }
        },
          voiceInputAvailable ? e('button', {
            onClick: handleAiAssistantVoice,
            disabled: aiChatVoiceState !== 'idle',
            title: 'Voice input (Finnish)',
            style: {
              padding: '12px 16px',
              background: aiChatVoiceState === 'listening' ? 'var(--gold)' : 'transparent',
              border: '1px solid var(--border-color)',
              borderRadius: '4px',
              color: aiChatVoiceState === 'listening' ? '#000' : 'var(--text)',
              cursor: aiChatVoiceState === 'idle' ? 'pointer' : 'not-allowed',
              fontFamily: 'IBM Plex Mono',
              fontSize: '16px'
            }
          }, aiChatVoiceState === 'listening' ? 'üéôÔ∏è' : 'üé§') : null,
          e('input', {
            type: 'text',
            value: aiChatInput,
            onChange: (ev) => setAiChatInput(ev.target.value),
            onKeyDown: (ev) => {
              if (ev.key === 'Enter' && !ev.shiftKey) {
                ev.preventDefault();
                sendAiAssistantMessage();
              }
            },
            placeholder: textSelection ? 'How should I revise this?' : 'Ask me anything...',
            disabled: aiChatProcessing,
            style: {
              flex: 1,
              padding: '12px',
              background: 'var(--bg-primary)',
              border: '1px solid var(--border-color)',
              borderRadius: '4px',
              color: 'var(--text)',
              fontFamily: 'IBM Plex Mono',
              fontSize: '12px',
              outline: 'none'
            }
          }),
          e('button', {
            onClick: sendAiAssistantMessage,
            disabled: aiChatProcessing || !aiChatInput.trim(),
            style: {
              padding: '12px 20px',
              background: aiChatProcessing || !aiChatInput.trim() ? 'var(--bg-2)' : 'var(--bronze)',
              border: 'none',
              borderRadius: '4px',
              color: aiChatProcessing || !aiChatInput.trim() ? 'var(--text-3)' : '#000',
              cursor: aiChatProcessing || !aiChatInput.trim() ? 'not-allowed' : 'pointer',
              fontFamily: 'IBM Plex Mono',
              fontSize: '12px',
              fontWeight: 600
            }
          }, aiChatProcessing ? '...' : '‚Üë')
        ),
        e('div', {
          style: {
            marginTop: '8px',
            fontFamily: 'IBM Plex Mono',
            fontSize: '9px',
            color: 'var(--text-3)',
            textAlign: 'center'
          }
        }, 'Cmd+K to toggle ‚Ä¢ Enter to send')
      )
    )
  );
}

// Mount the app
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(e(FAUSTApp));

console.log('[FAUST] Simple app loaded ‚ú®');
console.log('[FAUST] VERSION: 2025-10-22-23:40 - LIMINAL ENGINE ADDED');
